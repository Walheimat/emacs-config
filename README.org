#+TITLE: Walheimat's Emacs Config
#+AUTHOR: [[https://gitlab.com/Walheimat][@Walheimat]]
#+TOC: headlines 3

[[./assets/logo.png]]

* About

** Heads-up

This project is my personal literate Emacs (28.0.50)[fn:1] configuration.

If you're a complete beginner,
you will find [[https://github.com/emacs-tw/awesome-emacs#starter-kit][more user-friendly and less tailor-made configs]] out there.

Feel free to consider it a jumping-off-point for your own custom config.
Just know that nothing in this config should be considered _good practice_,
it's mostly just how I (think I) like things to be.

** Try-out

If you're interested in trying out Emacs using my config,
here are the necessary steps:

+ Install Emacs if you haven't[fn:2]
+ =git clone= this repository into your =user-emacs-directory=[fn:3]
+ copy the config file included in this repo by running =cp ~/.emacs.d/emacs-config/templates/.emacs ~=
+ close and re-run Emacs which should download and install all[fn:4] packages.

If you do not wish to =clone= this repo in your =user-emacs-directory= or use the default name,
you will need to adapt the variable =wal/emacs-config-default-path= in the example config you just copied.

** Peculiarities

*** Daemon Mode

This config is /daemon-ready/, i.e. if you start Emacs with the =--daemon= flag,
the config will make sure that any customization that requires a frame
will only be loaded once a frame was created.

A =systemd= service config can be found in the =/templates= directory to
get you started:

+ Run =mkdir -p ~/.config/systemd/user=
+ run =cp ~/.emacs.d/emacs-config/templates/emacs.service ~/.config/systemd/user=
+ adapt that =emacs.service= file to point to the correct path
+ run =systemctl --user enable emacs=.

Or you just execute =emacs --daemon= in a terminal or your shell's config.

In any case, an Emacs daemon will start (on start-up).
To connect you can use, for example, =emacsclient -c -n=, which I alias to =ec=.

*** Scope

I've tried to keep custom functions and variables in a scope
called =wal= to avoid potential interference.

Enough preambling, let's configure some Emacs.
The init script will evaluate _everything_[fn:5] that follows.

* Settings

** Speed

You want speed?
Then bind lexically!

#+BEGIN_SRC emacs-lisp
;;; README.el -*- lexical-binding: t; -*-
#+END_SRC

** Personal

Set some personal info[fn:6].

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Krister Schuchardt"
      user-mail-address "krister.schuchardt@theventury.com")

;; Warn Mac/Windows users.
(unless (eq system-type 'gnu/linux)
  (warn "\
    Warning: Config only tested on Linux.
    While I did get in running on Windows 10,
    it was quite tricky and involved setting unsafe options."))
#+END_SRC

** Start-Up

Customize start-up.

#+BEGIN_SRC emacs-lisp
;; Maximize frame.
(setq frame-resize-pixelwise t)
(add-to-list 'default-frame-alist '(fullscreen . maximized)) ;; Leads to issues when using a tiling wm.

;; No splash.
(setq inhibit-startup-message t)
(setq initial-major-mode 'fundamental-mode)

;; Use a distinct file for customization.
(setq custom-file (expand-file-name "custom.el" wal/emacs-config-default-path))

;; We'll create that file if it doesn't yet exist.
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))

;; Accept redefinitions.
(setq ad-redefinition-action 'accept)

(add-hook 'after-init-hook (lambda ()
                             (load custom-file)))
#+END_SRC

** Package Archives

Add MELPA and org-mode to our package archives.
We'll be getting most (if not all) packages from the prior.

#+BEGIN_SRC emacs-lisp
(require 'package)

(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl (warn "\
   Your version of Emacs does not support SSL connections,
   which is unsafe because it allows man-in-the-middle attacks.
   There are two things you can do about this warning:
   1. Install an Emacs version that does support SSL and be safe.
   2. Remove this warning from your init file so you won't see it again."))
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t))

;; Don't pin packages.
(setq package-pinned-packages '())

(package-initialize)
#+END_SRC

** Dependencies

Manage packages with =use-package=.
Before we can use it,
we have to install it and a few other packages the hard way.

#+BEGIN_SRC emacs-lisp
;; We need dash for the upcoming loop.
(unless (package-installed-p 'dash)
  (condition-case nil
      (package-install 'dash)
    (error (package-refresh-contents)
           (package-install 'dash))))
(require 'dash)

(defun wal/install-packages (packages)
  "Install all PACKAGES unless already installed."
  (--each packages
    (when (not (package-installed-p it))
      (package-install it)))
  (delete-other-windows))

(defvar wal/dependencies '(diminish delight use-package)
  "Packages to install before using `use-package'.")

;; Try to install. On fail refresh and install again.
(condition-case nil
    (wal/install-packages wal/dependencies)
  (error
   (package-refresh-contents)
   (wal/install-packages wal/dependencies)))

;; Ensure all packages by default.
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

** Directories

Make sure that custom directories exist.
We want:

+ A cache directory to store bookmarks, perspectives, prescience et al.
+ a directory for site lisp
+ a default directory for org files.

#+BEGIN_SRC emacs-lisp
(defvar wal/cache-directory
  (expand-file-name ".cache" user-emacs-directory)
  "The cache directory.")

(defvar wal/site-lisp-directory
  (expand-file-name "site-lisp" user-emacs-directory)
  "Directory of site Lisp packages.")

;; Change if necessary.
(defvar wal/org-directory (expand-file-name "org" "~")
  "My default directory for org files.")

;; I put all of my tasks into a subfolder `tasks' inside the org directory.
(defvar wal/agenda-tasks-directory
  (expand-file-name "tasks" wal/org-directory)
  "One-size-fits-all directory for agenda tasks.")

(defvar wal/org-roam-directory
  (expand-file-name "zettelkasten" wal/org-directory)
  "Directory for our note-taking.")

;; Create all dirs.
(--each
    `(,wal/org-roam-directory
      ,wal/agenda-tasks-directory
      ,wal/org-directory
      ,wal/site-lisp-directory
      ,wal/cache-directory)
  (unless (file-directory-p it)
    (make-directory it)))
#+END_SRC

** Site-Lisp

Add =site-lisp= directory and sub-directories to load path.
I put non-MELPA packages here.

If the directory doesn't exist, it will get created.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path wal/site-lisp-directory)

;; Allow us to load from site-lisp package.
(add-to-list 'custom-theme-load-path
             (expand-file-name "emacs-site-lisp" wal/site-lisp-directory))

;; Add subdirs as well.
(dolist (project (directory-files wal/site-lisp-directory t "\\w+"))
  (when (file-directory-p project)
    (add-to-list 'load-path project)))
#+END_SRC

** Persistent =*scratch*=

Let's keep the scratch contents.
This was cribbed from [[https://www.john2x.com/emacs.html][john2x's config]].

#+BEGIN_SRC emacs-lisp
;; Empty scratch message.
(setq initial-scratch-message "")

(defvar wal/scratch-persist-file
  (expand-file-name "scratch-persist" wal/cache-directory)
  "The file to persist the *scratch* buffer's content in.")

(defun wal/persist-scratch ()
  "Persist contents of *scratch* buffer."
  (interactive)
  (with-current-buffer (get-buffer-create "*scratch*")
    (write-region (point-min) (point-max) wal/scratch-persist-file)))

(defun wal/rehydrate-scratch ()
  "Re-hydrate scratch buffer (if persisted)."
  (if (file-exists-p wal/scratch-persist-file)
      (with-current-buffer (get-buffer "*scratch*")
        (delete-region (point-min) (point-max))
        (insert-file-contents wal/scratch-persist-file))))

(add-hook 'after-init-hook #'wal/rehydrate-scratch)
(add-hook 'kill-emacs-hook #'wal/persist-scratch)
#+END_SRC

** Saving and Backups

Don't clutter up workspaces.

#+BEGIN_SRC emacs-lisp
;; Save places and do so in a file.
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

;; Store backups in backups folder.
(setq backup-directory-alist
      `(("." . ,(expand-file-name (concat user-emacs-directory "backups")))))

;; Store autosaves in temp folder.
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; We don't want this to mess with git.
(setq create-lockfiles nil)
#+END_SRC

** Global Modes

Modes that should be on/off no matter what.

#+BEGIN_SRC emacs-lisp
;; A bunch of useful modes.
(show-paren-mode 1)
(global-auto-revert-mode 1)
(global-prettify-symbols-mode 1)
(save-place-mode 1)
(global-font-lock-mode 1)
(delete-selection-mode 1)
(column-number-mode 1)

;; No need for bars.
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Reasonable Sizes

Make things shorter and snappier.

#+BEGIN_SRC emacs-lisp
(defconst wal/one-mb
  (* 1024 1024)
  "One megabyte.")

(setq mouse-yank-at-point t
      show-paren-delay 0.0
      read-process-output-max wal/one-mb
      sentence-end-double-space nil
      echo-keystrokes 0.1)

;; Simple y/n is enough.
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Indentation

Set up an easy way to switch between tabs
and spaces for indentation.

#+BEGIN_SRC emacs-lisp
(defvar wal/tab-width 4
  "A tab width 4 spaces wide.")

(defvar wal/prefer-tabs t
  "Whether tabs are used for indentation.")

(defvar wal/allow-custom-indent-line-fun t
  "Whether a custom `indent-line-function' can be passed.")

(defun wal/reset-tab-width ()
  "Reset the tab width to the standard."
  (interactive)
  (setq tab-width (eval (car (get 'tab-width 'standard-value)))))

(defun wal/disable-tabs ()
  "Disable `indent-tabs-mode'."
  (interactive)
  (local-unset-key (kbd "TAB"))
  (setq indent-tabs-mode nil))

(defun wal/enable-tabs ()
  "Use TAB key and turn on `indent-tabs-mode'."
  (interactive)
  (local-set-key (kbd "TAB") 'tab-to-tab-stop)
  (setq indent-tabs-mode t))

(defun wal/maybe-enable-tabs (&optional tab-indent-fun mode-fun)
  "Maybe enable tabs using TAB-INDENT-FUN and MODE-FUN to do so."
  (if wal/prefer-tabs
      (progn
        (wal/enable-tabs)
        (when (and wal/allow-custom-indent-line-fun tab-indent-fun)
          (setq-local indent-line-function tab-indent-fun))
        (when mode-fun
          (funcall mode-fun)))
    (wal/disable-tabs)))

(defun wal/set-indent-defaults (&optional num)
  "Set indent defaults, optionally to NUM."
  (interactive "nSet tab width to: ")
  (let ((width (or num wal/tab-width)))
    (setq-default python-indent-offset width ; Python
                  js-indent-level width ; Javascript
                  css-indent-offset width ; CSS and SCSS
                  electric-indent-inhibit t
                  tab-width width
                  indent-tabs-mode wal/prefer-tabs)
    (setq backward-delete-char-untabify-method 'hungry)))

(add-hook 'after-init-hook 'wal/set-indent-defaults)
#+END_SRC

*** Dir Local Indentation

Sometimes you have to play using other people's rules.
You can run =add-dir-local-variable= to do so.
Check out the =.dir-locals.el= template found in the =/templates= folder
for an example using spaces.

** White space

Delete trailing white space before saving.

#+BEGIN_SRC emacs-lisp
;; Set to `nil' in `.dir-locals.el' if necessary.
(defvar wal/delete-trailing-whitespace t
  "Whether to delete trailing whitespace.")

(defun wal/delete-trailing-whitespace-maybe ()
  "Maybe delete trailing whitespace."
  (when wal/delete-trailing-whitespace
    (delete-trailing-whitespace))
  nil)

(add-hook 'write-file-functions #'wal/delete-trailing-whitespace-maybe)
#+END_SRC

** Zoning

Zone out after a couple of minutes.

#+BEGIN_SRC emacs-lisp
(defvar wal/zone-timer (* 5 60)
  "The time in seconds when we will zone out.")

(use-package zone
  :ensure nil
  :defer 2
  :config
  (zone-when-idle wal/zone-timer))
#+END_SRC

* Additional Functions

** Garbage Collection

Better(?) garbage collection.

#+BEGIN_SRC emacs-lisp
;; Trick garbage collection.
(defconst wal/hundred-mb
  (* 1024 1024 100)
  "A hundred megabytes.")

(defun wal/minibuffer-setup-hook ()
  "Increase gc threshold to maximum on minibuffer setup."
  (setq gc-cons-threshold most-positive-fixnum))

(defun wal/minibuffer-exit-hook ()
  "Decrease it again on minibuffer exit."
  (setq gc-cons-threshold wal/hundred-mb))

(add-hook 'minibuffer-setup-hook #'wal/minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'wal/minibuffer-exit-hook)
#+END_SRC

** Directories

Finding files should =mkdir -p= its parents.

#+BEGIN_SRC emacs-lisp
;; Creating parent dirs.
(defun wal/create-non-existent-directory ()
  "Ask whether to create non-existent directory.
If a file is found in a not (yet) existing directory,
ask if it should get created."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Create non-existing directory `%s'? " parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions #'wal/create-non-existent-directory)

;; Don't care about `.' and `..'.
(defun wal/directory-files (directory)
  "Get all directory files in DIRECTORY except for current and parent directories."
  (nthcdr 2 (directory-files directory t)))
#+END_SRC

** Buffers

Ignore some buffers when switching.

#+BEGIN_SRC emacs-lisp
(defvar wal/commonly-ignored-major-modes
  '(dired-mode helpful-mode magit-diff-mode vterm-mode)
  "Major modes whose buffers should be commonly ignored.")

(defun wal/commmonly-ignored-buffer-p (buffer-or-string)
  "Check if provided BUFFER-OR-STRING is commonly ignored."
  (let ((maj (with-current-buffer
                 (get-buffer-create buffer-or-string)
               major-mode)))
    (or (member maj wal/commonly-ignored-major-modes)
        ;; Starred buffers other than scratch buffers.
        (and (not (string-match "^\\*scratch" buffer-or-string))
             (string-match "^\\*[[:ascii:]]+\\*\\'" buffer-or-string)))))
#+END_SRC

** Windows

I keep messing up, splitting vertically when I meant horizontally.
This is inspired by [[https://github.com/purcell/emacs.d/blob/master][purcell's config]].

#+BEGIN_SRC emacs-lisp
(defun wal/split-window-the-other-way ()
  "Split window the other way.
This means if horizontally split, split vertically;
if vertically split, split horizontally."
  (interactive)
  (let* ((other-buffer (and (next-window) (window-buffer (next-window))))
         (win (selected-window))
         (split-direction (cond ((or (windows-sharing-edge win 'above)
                                     (windows-sharing-edge win 'below))
                                 'vert)
                                ((or (windows-sharing-edge win 'right)
                                     (windows-sharing-edge win 'left))
                                 'hori)
                                (t nil))))
    (delete-other-windows)
    (pcase split-direction
      ('vert (split-window-horizontally))
      ('hori (split-window-vertically))
      (_ nil))
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(define-minor-mode walled-mode
  "Dedicate the window."
  :init-value nil
  :lighter " wld"
  (cond
   (noninteractive
    (setq walled-mode nil))
   (walled-mode
    (walled-mode--enable))
   (t
    (walled-mode--disable))))

(defun walled-mode--enable ()
  "Dedicate the window to buffer."
  (let ((window (selected-window))
        (bufname (current-buffer)))
    (set-window-dedicated-p window bufname)
    (message "Dedicating window")))

(defun walled-mode--disable ()
  "Make window no longer dedicated."
  (let ((window (selected-window)))
    (set-window-dedicated-p window nil)
    (message "Window no longer dedicated")))

(defun wal/edge (scale-above scale-below)
  "Move the window splitter using SCALE-ABOVE and SCALE-BELOW."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'above) scale-above)
                          ((windows-sharing-edge win 'below) scale-below)
                          (t nil))))
    (pcase direction
      ('enlarge (wal/enlarge-window))
      ('shrink (wal/shrink-window))
      (_ nil))))

(defun wal/edge-horizontally (scale-left scale-right)
  "Move the window splitter using SCALE-LEFT and SCALE-RIGHT."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'left) scale-left)
                          ((windows-sharing-edge win 'right) scale-right)
                          (t nil))))
    (pcase direction
      ('enlarge (wal/enlarge-window-horizontally))
      ('shrink (wal/shrink-window-horizontally))
      (_ nil))))

(defun wal/edge-left ()
  "Move the splitter of the selected window left.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'enlarge 'shrink))

(defun wal/edge-right ()
  "Move the splitter of the selected window right.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'shrink 'enlarge))

(defun wal/edge-up ()
  "Move the splitter of the selected window up.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'enlarge 'shrink))

(defun wal/edge-down ()
  "Move the splitter of the selected window down.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'shrink 'enlarge))

(defun wal/shrink-window (&optional horizontally)
  "Shrink the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-min-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))
    (if horizontally
        (shrink-window-horizontally chunk)
      (shrink-window chunk))))

(defun wal/shrink-window-horizontally ()
  "Shrink the selected window horizontally."
  (interactive)
  (wal/shrink-window t))

(defun wal/enlarge-window (&optional horizontally)
  "Enlarge the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-max-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))
    (if horizontally
        (enlarge-window-horizontally chunk)
      (enlarge-window chunk))))

(defun wal/enlarge-window-horizontally ()
  "Enlarge the selected window horizontally."
  (interactive)
  (wal/enlarge-window t))
#+END_SRC

** Buffer Display

Utility functions to configure displaying buffers of a certain type.

#+BEGIN_SRC emacs-lisp
(defun wal/display-buffer-condition (buffer-or-mode)
  "Get a display buffer condition for BUFFER-OR-MODE."
  (pcase buffer-or-mode
    ((pred stringp) buffer-or-mode)
    ((pred symbolp) `(lambda (bufname _)
                       (with-current-buffer bufname
                         (equal major-mode (intern ,(symbol-name buffer-or-mode))))))
    (_ nil)))

(defun wal/configure-shell-buffer-display (buffer)
  "Configure `display-buffer' for shell BUFFER."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-in-side-window)
                   (side . bottom)
                   (dedicated . t)
                   (reusable-frames . visible)))))

(defun wal/configure-result-buffer-display (buffer &optional in-frame)
  "Configure BUFFER to be displayed in pop-up window (or IN-FRAME)."
  (let ((condition (wal/display-buffer-condition buffer))
        (dispfun (if in-frame
                     'display-buffer-pop-up-frame
                   'display-buffer-pop-up-window)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (,dispfun)))))

(defun wal/configure-help-buffer-display (buffer &optional direction)
  "Configure `display-buffer' for help BUFFER in DIRECTION."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-in-direction)
                   (direction . ,(or direction 'rightmost))))))

(defun wal/configure-focus-buffer-display (buffer)
  "Configure `display-buffer' for focus BUFFER."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-in-side-window)
                   (side . top)))))
#+END_SRC

* Key Bindings

I use many[fn:7] custom keybindings.

** Control

There are some non-standard control sequences.
Anywhere:

+ =C->=/=C-<= expands/contracts region
+ =C-.= marks next point like this allowing
  + =C-,= to delete last mark and
  + =C-/= to move it
+ =C-?= redoes (as =C-/= undoes).

User-reserved combinations are used for certain command maps:

+ =C-c i= for =perspective=
+ =C-c p= for =projectile=, if the modes are active
+ =C-c f= for =flycheck=
+ =C-c l= for =lsp=
+ =C-c v= for =vdiff=.

It's also used for certain dispatches:

+ =C-c a= for =org-agenda=
+ =C-c d= for =docker=
+ =C-c g= for =magit=
+ =C-c m= for =bookmark=.

It's also used in a few actions:

+ =C-c z= for =org-roam=.

** Hyper

Most hyper bindings are quick-access actions:

+ =H-d= duplicates current line/region with =crux=
+ =H-e= to open (or cycle using =E=) pop-up
+ =H-<mouse3>= adds another cursor at point
+ =H-q= to do a quick calculation
+ =H-<TAB>= expands snippets (in =yas-minor-mode=)
+ =H-t= toggles =vterm=.

And in =prog mode=-derived modes (as well as =yaml-mode=):

+ =H-c= comments a line.

It's also used as a [[*About Leader Keys][leader key]] for certain dispatches.

*** Caps to Hyper

I re-bound my =<CAPS>= (caps-lock) key to =Hyper_L= to use the
hyper bindings above.

If you use Xorg Display Server,
you can do this by editing[fn:8] your =/usr/share/X11/xkb/symbols/pc= file like so:

#+BEGIN_SRC
...
// key <CAPS> {    [ Caps_Lock     ]   };
key <CAPS> {    [ Hyper_L       ]   };
...
// modifier_map Lock   { Caps_Lock };
modifier_map Mod3   { Hyper_L, Hyper_R };
...
// modifier_map Mod4   { <HYPR> };
modifier_map Mod3   { <HYPR> };
#+END_SRC

** General

The are four multi-purpose =general= leader keys.
They prefix actions by common context.

#+BEGIN_SRC emacs-lisp
;; American ranks.
(defvar wal/general-key "H-;"
  "Wal's primary (or general) leader key.")

(defvar wal/colonel-key "H-'"
  "Wal's secondary (or colonel) leader key.")

(defvar wal/major-key "H-,"
  "Wal's tertiary (or major) leader key.")

(defvar wal/captain-key "H-."
  "Wal's quaternary (or captain) leader key.")

(use-package general
  :defer t
  :config
  (general-create-definer wal/general
    :prefix wal/general-key)
  (wal/general "c" '(:ignore t :wk "config"))
  (wal/general "o" '(:ignore t :wk "other"))
  (general-create-definer wal/colonel
    :prefix wal/colonel-key)
  (general-create-definer wal/major
    :prefix wal/major-key)
  (general-create-definer wal/captain
    :prefix wal/captain-key))
#+END_SRC

*** About Leader Keys

Leader key =general= prefixes Emacs actions
like loading a theme, scaling text, quitting.

Leader key =colonel= prefixes mode toggles.
Available modes might depend on =major-mode=.

Leader keys =major= and =captain= prefix mode-specific actions,
for major and minor modes respectively.

There are also eight package-specific leader keys that
act like (or bind to) dispatches. They prefix a subset of actions
I commonly use, with a repeated key denoting the most common one:

+ =H-l= for =avy= (where =l= goes to line)
+ =H-p= for =projectile= (where =p= switches projects)
+ =H-i= for =perspective= (where =i= switches perspective)
+ =H-s= for =ag= (where =s= searches in directory)
+ =H-w= for =ace-window= (where =w= deletes other windows)
+ =H-c= for =multiple-cursors= (where =c= selects all like this)
+ =H-b= for =eww= (where =b= opens browser)
+ =H-z= for =org-roam=[fn:9] (where =z= finds a note).

** Hydra

Provides a context for related commands that can
be (re-)executed in quick succession.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :defer t)

;; Use `hydra' to resize windows.
(defhydra wal/resize-window (:timeout 1
                             :hint nil)
  "
  ^_p_^
_b_   _f_ Move window splitter.
  ^_n_^
"
  ("b" wal/edge-left)
  ("f" wal/edge-right)
  ("n" wal/edge-down)
  ("p" wal/edge-up)
  ("o" wal/split-window-the-other-way "split the other way")
  ("q" nil "cancel"))

(wal/general "w" '(wal/resize-window/body :wk "resize window"))
#+END_SRC

** Additional Mode Controls

Turning off certain minor modes and
switching between =major-mode= and =fundamental-mode=.

#+BEGIN_SRC emacs-lisp
(defvar wal/before-fundamental-mode nil
  "The major mode before fundamental was engaged.")

(defun wal/fundamental-mode ()
  "Switch from `major-mode' to `fundamental-mode' and back."
  (interactive)
  (let ((m-mode major-mode))
    (if wal/before-fundamental-mode
        (progn
          (funcall wal/before-fundamental-mode)
          (setq wal/before-fundamental-mode nil))
      (fundamental-mode)
      (make-local-variable 'wal/before-fundamental-mode)
      (setq wal/before-fundamental-mode m-mode))))

(wal/colonel "f" '(wal/fundamental-mode :wk "fundamental")
             "n" '(linum-mode :wk "linum"))
#+END_SRC

** Additional (Un-)Bindings

Most bindings are declared in the [[*Packages][packages]] section.

#+BEGIN_SRC emacs-lisp
(defvar wal/readme-config
  (expand-file-name "README.org" wal/emacs-config-default-path)
  "The path to this config file.")

(defun wal/open-config ()
  "Open this very config."
  (interactive)
  (switch-to-buffer (find-file-noselect wal/readme-config)))

(wal/general "co" '(wal/open-config :wk "open")
             "ct" '(wal/tangle-config :wk "tangle"))

;;; Windows, frames and buffers.
(wal/colonel "." '(walled-mode :wk "walled"))
(global-unset-key (kbd "C-z")) ; Unsets `suspend-frame'.

;; Killing Emacs.
(global-unset-key (kbd "C-x C-c"))
(wal/general "q" '(save-buffers-kill-terminal :wk "quit Emacs"))

;; No triple-ESC.
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

;; Scaling text in buffer.
(defhydra wal/text-scale (:timeout 1)
  "
_i_ncrease or _d_ecrease text size
"
  ("i" text-scale-increase)
  ("d" text-scale-decrease)
  ("q" nil "cancel"))

(wal/general "s" '(wal/text-scale/body :wk "scale text"))
#+END_SRC

* Look

Make frame transparent and set themes.
[[https://peach-melpa.org/][PeachMelpa]] has more themes.

#+BEGIN_SRC emacs-lisp
;; Transparency.
(defvar wal/transparency 90
  "The default frame transparency.")

(defun wal/transparency (&optional value)
  "Set the transparency of the frame window to VALUE.
1 being (almost) completely transparent, 100 being opaque."
  (interactive "nSet transparency (1-100): ")
  (let ((transparency (min (max (or value wal/transparency) 1) 100)))
    (set-frame-parameter (selected-frame) 'alpha transparency)))

;; Two themes and a switch.
(defvar wal/primary-emacs-theme 'kaolin-valley-dark
  "The quote-unquote default Emacs theme.")

;; Use `setq' in your .emacs to switch.
(defvar wal/secondary-emacs-theme 'kaolin-valley-light
  "The non-default Emacs theme.")

(defvar wal/active-theme nil
  "The active theme.")

(defun wal/light-switch (&optional selection)
  "Switch to SELECTION or from light to dark theme and vice-versa."
  (interactive)
  (disable-theme wal/active-theme)
  (cond ((or (equal wal/active-theme wal/primary-emacs-theme) (equal selection 'secondary))
         (load-theme wal/secondary-emacs-theme t)
         (setq wal/active-theme wal/secondary-emacs-theme))
        ((or (equal wal/active-theme wal/secondary-emacs-theme) (equal selection 'primary))
         (load-theme wal/primary-emacs-theme t)
         (setq wal/active-theme wal/primary-emacs-theme))))

;; Some themes require configuration, so we only load after initialization.
(defun wal/setup-visuals ()
  "Setup visual frills like theme and transparency."
  (interactive)
  (load-theme wal/primary-emacs-theme t)
  (setq wal/active-theme wal/primary-emacs-theme)
  (wal/transparency))

(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'wal/setup-visuals)
  ;; Function `wal/transparency' hasn't been untangled yet.
  (add-hook 'after-init-hook 'wal/setup-visuals)
  ;; This means all future frames will have the original transparency
  ;; not the current one.
  (add-to-list 'default-frame-alist `(alpha . ,wal/transparency)))
#+END_SRC

* Fonts

Set fonts (with preference).
To get support for ligatures, install the symbol font from [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][here]].

#+BEGIN_SRC emacs-lisp
(defvar wal/fixed-fonts
  '("Iosevka"
    "Input Mono"
    "mononoki"
    "Fira Code"
    "JetBrains Mono"
    "Source Code Pro"
    "DejaVu Sans Mono"
    "Monoid" ;; Be sure to install the no-calt variant!
    "Liberation Mono")
  "Fixed fonts ordered by preference.")

(defvar wal/variable-fonts
  '("Roboto" "Ubuntu" "San Francisco" "Arial")
  "Variable fonts ordered by preference.")

(defvar wal/fixed-font-height 120
  "The font height for fixed fonts.")

(defvar wal/variable-font-height 140
  "The font height for variable fonts.")

(defun wal/fixed-fonts-select (font)
  "Select fixed FONT."
  (interactive (list (completing-read "Select font: " wal/fixed-fonts)))
  (let ((found (find-font (font-spec :name font))))
    (when found
      (set-face-attribute 'default nil
                          :font found
                          :height wal/fixed-font-height))))

(defun wal/fonts-candidate (fonts)
  "Return the first available font from a list of FONTS."
  (--first (find-font (font-spec :name it)) fonts))

(defun wal/setup-fonts ()
  "Setup fonts."
  (set-face-attribute 'default nil
                      :font (wal/fonts-candidate wal/fixed-fonts)
                      :height wal/fixed-font-height)
  ;; Variable pitch face.
  (set-face-attribute 'variable-pitch nil
                      :font (wal/fonts-candidate wal/variable-fonts)
                      :height wal/variable-font-height))

;; Fonts can't be initialized thru daemon.
(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'wal/setup-fonts)
  (add-hook 'after-init-hook 'wal/setup-fonts))

;; I want my comments slanted and my keywords bold.
;; The FiraCode font does not support this.
(defun wal/font-lock ()
  "Slanted and enchanted."
  (set-face-attribute 'font-lock-comment-face nil :slant 'italic :weight 'normal)
  (set-face-attribute 'font-lock-keyword-face nil :weight 'bold))

(add-hook 'font-lock-mode-hook 'wal/font-lock)
#+END_SRC

* Packages

What follows is a list of packages[fn:10] that make Emacs even more awesome.

If you wish to know more about any of them, check out the [[file:etc/packages.org][list of repositories]]
now kept in a different file or the [[https://github.com/emacs-tw/awesome-emacs][awesome-emacs]] project.

** Emacs

Everything that has to do with Emacs-y stuff.

*** which-key

Show the next possible key presses towards an action.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer t
  :diminish
  :custom
  (which-key-idle-delay 1.5)
  (which-key-idle-secondary-delay 0.4)
  :config
  (which-key-mode))
#+END_SRC

*** helpful

Let's try (to be) =helpful=.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :after counsel
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :config
  (wal/configure-help-buffer-display 'helpful-mode)
  :general
  (wal/major :keymaps '(emacs-lisp-mode-map org-mode-map)
    "h"  '(helpful-at-point :wk "at point"))
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))

(use-package help-mode
  :defer t
  :ensure nil
  :config
  (wal/configure-help-buffer-display 'help-mode))
#+END_SRC

*** dashboard

Let's have a dash of board.

#+BEGIN_SRC emacs-lisp
;; Dependency.
(use-package page-break-lines
  :defer 1
  :delight " pbl")

;; Using my gitlab status messages, only one so far.
(defvar wal/dashboard-footer-messages
  '(":whale2: breaching your favorite stupid framework"
    ":whale: I propel myself forward on nothing but flukes"
    ":whale2: krill, filter feeders and hit sulphur bottom"
    ":whale: devout and up the spout")
  "The footer messages I can stand to see.")

;; Ignore all files that were loaded on start-up.
(defvar wal/recentf-exclude
  (append (wal/directory-files wal/agenda-tasks-directory)
          (wal/directory-files wal/org-roam-directory)
          (wal/directory-files wal/cache-directory)
          (wal/directory-files user-emacs-directory))
  "Files that should not be considered recent files.")

(use-package dashboard
  :hook (after-init . dashboard-setup-startup-hook)
  :custom
  (dashboard-banner-logo-title "Walheimat's Emacs Config")
  (dashboard-startup-banner (expand-file-name
                             "assets/logo.png"
                             wal/emacs-config-default-path))
  (dashboard-projects-backend 'projectile)
  (dashboard-items '((recents . 5)
                     (projects . 5)
                     ;; This means all agenda files are opened
                     ;; which I find annoying.
                     ;; (agenda    . 5)
                     (bookmarks . 5)))
  (dashboard-center-content t)
  (dashboard-set-file-icons t)
  (dashboard-set-navigator t)
  (dashboard-footer-messages wal/dashboard-footer-messages)
  (dashboard-set-init-info t)
  (dashboard-week-agenda nil)
  (dashboard-agenda-time-string-format "%d/%m/%y")
  :config
  (advice-add 'dashboard-insert-startupify-lists
              :around (lambda (fun &rest r)
                        (let ((recentf-exclude wal/recentf-exclude))
                          (apply fun r)))))
#+END_SRC

*** use-package-ensure-system-package

Ensure binaries.

#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :defer t)
#+END_SRC

*** restart-emacs

Sometimes I restart for fun.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :if (not (daemonp))
  :custom
  (restart-emacs-restore-frames nil)
  :general
  (wal/general "r" '(restart-emacs :wk "restart Emacs")))
#+END_SRC

*** debug

Just want to position this.

#+BEGIN_SRC emacs-lisp
(use-package debug
  :defer t
  :ensure nil
  :config
  (wal/configure-help-buffer-display 'debug-mode 'bottom))
#+END_SRC

*** bookmark

I used to use =bm= package but the built-in
package seems better now.

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :ensure nil
  :defer t
  :custom
  (bookmark-use-annotations t)
  (bookmark-automatically-show-annotations nil)
  :config
  (wal/configure-help-buffer-display "\\*Bookmark Annotation\\*")
  :bind-keymap
  ("C-c m" . bookmark-map)
  :bind
  (:map bookmark-map
    ("a" . bookmark-bmenu-list)))
#+END_SRC

*** async

It's currently mostly a dependency of other packages.

#+BEGIN_SRC emacs-lisp
(use-package async
  :defer 4
  :diminish 'dired-async-mode
  :config
  (dired-async-mode 1))
#+END_SRC

*** calc

Get out your calculators!

#+BEGIN_SRC emacs-lisp
(use-package calc
  :ensure nil
  :bind
  ;; Quick calculations!
  ("H-q" . quick-calc))
#+END_SRC

*** package

We need some shortcuts.

#+begin_src emacs-lisp
(use-package package
  :ensure nil
  :general
  (wal/general "p" '(:ignore t :wk "package")
    "pf" '(package-refresh-contents :wk "refresh")
    "pi" '(package-install :wk "install")
    "pr" '(package-reinstall :wk "re-install")
    "pd" '(package-delete :wk "delete")))
#+end_src

*** tablist

=hl-line= really helps here.

#+begin_src emacs-lisp
(defun wal/tablist-mode ()
  "Hook into `tablist-mode' and `tabulated-list-mode'."
  (hl-line-mode))

(use-package tablist
  :defer t
  :ensure nil
  :hook
  ((tablist-minor-mode . wal/tablist-mode)
   (tabulated-list-mode . wal/tablist-mode)))
#+end_src

** Org

Org mode is the best thing about Emacs. Check out the [[https://orgmode.org/manual/][manual]].
This configuration is a bit elaborate.

#+BEGIN_SRC emacs-lisp
(defun wal/org-mode ()
  "Life shouldn't be a drag in `org-mode'."
  (message "Organize! Seize the means of production!")
  ;; Require here to shorten start-up time.
  (wal/disable-tabs)
  ;; Since `9.4' org tries to please `electric-indent'.
  ;; (electric-indent-local-mode -1)
  ;; Disable `drag-stuff-mode'.
  (drag-stuff-mode -1))

(use-package org
  :ensure nil
  :hook (org-mode . wal/org-mode)
  :config
  (define-key org-mode-map (kbd "C-,") nil) ; Remove `org-cycle-agenda-files'.
  (add-to-list 'org-src-lang-modes '("docker" . dockerfile))
  (add-to-list 'org-src-lang-modes '("conf" . conf))
  (advice-add 'org-export-dispatch :before (lambda()
                                             (interactive)
                                             (require 'ox-md nil t)))
  :custom
  (org-src-tab-acts-natively nil) ; Defaults to `t' nowadays.
  (org-edit-src-content-indentation 0) ; Defaults to `2' nowadays.
  (org-adapt-indentation nil) ; Defaults to `t' nowadays ...
  (org-ellipsis "↷")
  (org-log-done t)
  (org-startup-truncated nil)
  (org-startup-folded 'overview)
  (org-directory wal/org-directory)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-agenda-files `(,wal/agenda-tasks-directory))
  (org-startup-with-inline-images t)
  ;; Be sure to add archive tag with `org-toggle-archive-tag'.
  (org-archive-location "::* Archived")
  (org-log-done 'time)
  ;; Too many clock entries clutter up a heading.
  (org-log-into-drawer t)
  (org-todo-keywords
   '((sequence "TODO(t)" "IN PROGRESS(p)" "WAITING(w)" "BLOCKED (b)" "|" "DONE(d)" "CANCELLED(c)")))
  (org-tag-alist
   '(;; depth
     ("@immersive" . ?i)
     ("@process" . ?p)
     ;; context
     ("@work" . ?w)
     ("@home" . ?h)
     ("@away" . ?a)
     ("@repeated" . ?r)
     ;; time
     ("@short" . ?<)
     ("@medium" . ?=)
     ("@long" . ?>)
     ;; energy
     ("@easy" . ?1)
     ("@average" . ?2)
     ("@challenge" . ?3)
     ;; category
     ("@dev" . ?d)
     ("@bla" . ?b)
     ("@edu" . ?e)))
  :general
  (wal/major :keymaps 'org-mode-map
    "e" '(org-edit-src-code :wk "edit source code")
    "n" '(org-add-note :wk "add note")
    "f" '(:ignore t :wk "footnotes")
    "ff" '(org-footnote-new :wk "add new")
    "fn" '(org-footnote-normalize :wk "normalize"))
  (wal/colonel :keymaps 'org-mode-map
    "i" '(org-indent-mode :wk "toggle indent")))
#+END_SRC

*** Agendas

Everything concerning agendas.

This is mostly based on [[https://github.com/mwfogleman/.emacs.d/blob/master/michael.org][mwfogleman]]'s Emacs config.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :ensure nil
  :custom
  ;; We hide all @-tags.
  (org-agenda-hide-tags-regexp "@")
  :bind
  ("C-c a" . org-agenda))
#+END_SRC

**** org-super-agenda

Nice agendas.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :after org-agenda
  :demand
  :custom
  (org-super-agenda-groups
   '((:name "Schedule"
            :time-grid t)
     (:name "Unscheduled"
            :scheduled nil)
     (:name "Leftovers"
            :and (:todo ("IN PROGRESS" "WAITING")
                        :scheduled past
                        :not (:tag "@repeated")))
     (:name "Blocked"
            :todo ("BLOCKED"))
     (:discard (:anything t))))
  :config
  ;; Not sure why this can't be in config.
  (org-super-agenda-mode)
  :general
  (wal/major :keymaps 'org-agenda-keymap
    "w" '(org-agenda-write :wk "write")))
#+END_SRC

*** org-tree-slide

Use =org-tree-slide= for presentations.

#+BEGIN_SRC emacs-lisp
(defun wal/tree-slide-toggle-visibility ()
  "Toggle visibility of line and cursor."
  (interactive)
  (if (bound-and-true-p global-hl-line-mode)
      (progn
        (setq cursor-type nil)
        (global-hl-line-mode -1))
    (progn
      (setq cursor-type t)
      (global-hl-line-mode 1))))

(defun wal/tree-slide-play ()
  "Make presentable."
  (setq visual-fill-column-width 140
        visual-fill-column-center-text t)
  (zone-leave-me-alone)
  (global-hl-line-mode -1)
  (beacon-mode -1)
  (visual-fill-column-mode 1))

(defun wal/tree-slide-stop ()
  "We no longer care about presentation."
  (setq visual-fill-column-width nil
        visual-fill-column-center-text nil)
  (zone-when-idle wal/zone-timer)
  (global-hl-line-mode 1)
  (beacon-mode 1)
  (visual-fill-column-mode -1))

(use-package org-tree-slide
  :custom
  (org-tree-slide-never-touch-face t)
  (org-tree-slide-cursor-init nil)
  (org-tree-slide-activate-message "We're on a road to nowhere")
  (org-tree-slide-deactivate-message "Take you here, take you there")
  (org-tree-slide-indicator '(:next "   >>>" :previous "<<<" :content "< Here is where time is on our side >"))
  :diminish buffer-face-mode
  :hook ((org-tree-slide-play . wal/tree-slide-play)
         (org-tree-slide-stop . wal/tree-slide-stop))
  :general
  (wal/major :keymaps 'org-mode-map
    "p" '(org-tree-slide-mode :wk "presentation"))
  :bind
  (:map org-tree-slide-mode-map
   ("n" . org-tree-slide-move-next-tree)
   ("p" . org-tree-slide-move-previous-tree)
   ("v" . wal/tree-slide-toggle-visibility)))
#+END_SRC

*** org-roam

Trying to organize my thoughts using Zettelkästen.
/Note/ that you will need to install =sqlite3= and =graphviz= manually.

#+BEGIN_SRC emacs-lisp
(defvar wal/org-roam-dailies-directory "tagebuch/"
  "The directory for dailies.")

;; Has to be created manually for now.
(defvar wal/org-roam-index-file "verzeichnis.org"
  "The name of the index file.")

;; Not sure why we need to do it this way.
(let ((index-file (expand-file-name wal/org-roam-index-file wal/org-roam-directory)))
  (unless (file-exists-p index-file)
    (write-region "* Zettelkasten" nil index-file)))

(defvar wal/org-roam-leader-key "H-z"
  "Leader key for `org-roam'.")

(general-create-definer wal/org-roam-leader
  :keymaps 'org-roam-map
  :prefix wal/org-roam-leader-key
  :prefix-command 'wal/org-roam-command
  :prefix-map 'wal/org-roam-map
  :prefix-name "roam")

(use-package org-roam
  :delight " zet"
  :if (executable-find "sqlite3")
  :custom
  (org-roam-directory wal/org-roam-directory)
  (org-roam-index-file wal/org-roam-index-file)
  (org-roam-dailies-directory wal/org-roam-dailies-directory)
  (org-roam-completion-system 'ivy)
  :general
  (wal/org-roam-leader
    "z" '(org-roam-find-file :wk "find")
    "c" '(org-roam-capture :wk "capture"))
  :bind ("C-c z" . org-roam-jump-to-index)
  :config
  (let* ((fname (concat wal/org-roam-dailies-directory "%<%Y-%m-%d>")))
    (setq org-roam-dailies-capture-templates
          `(("w" "work" entry
             #'org-roam-capture--get-point
             "* %?"
             :file-name ,fname
             :head "#+title: %<%Y-%m-%d>\n"
             :olp ("Work notes"))

            ("j" "journal" entry
             #'org-roam-capture--get-point
             "* %?"
             :file-name ,fname
             :head "#+title: %<%Y-%m-%d>\n"
             :olp ("Journal")))))
  ;; Theoretically these should be `wal/major' but these are minor of major.
  ;; We only add these to `org-mode' after the package was loaded.
  (wal/captain :keymaps 'org-mode-map
    "z" '(:ignore t :wk "roam")
    "zi" '(org-roam-insert :wk "insert other note")
    "zr" '(org-roam :wk "roam from here")
    "zg" '(org-roam-graph :wk "write graph"))
  (org-roam-mode))
#+END_SRC

*** Other

Other configurations and packages.

**** org-bullets

Prettier headlines.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . (lambda() (org-bullets-mode t))))
#+END_SRC

**** org-clock

Clock in, clock out.

#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :ensure nil
  :after org
  :custom
  (org-clock-idle-time 10)
  (org-clock-continuously t)
  (org-clock-persist t)
  (org-clock-in-switch-to-state "IN PROGRESS")
  (org-clock-in-resume t)
  (org-clock-report-include-clocking-task t)
  (org-clock-out-remove-zero-time-clocks t)
  (org-clock-into-drawer t))
#+END_SRC

**** org-keys

#+BEGIN_SRC emacs-lisp
(use-package org-keys
  :ensure nil
  :after org
  :custom
  (org-use-speed-commands t)
  (org-speed-commands-user
   '(("w" widen)
     ("n" org-narrow-to-subtree)
     ;; Defaults are I and O.
     ("i" org-clock-in)
     ("o" org-clock-out)
     ("a" org-archive-subtree)
     ("r" org-clock-report))))
#+END_SRC

** Dired

Group directories first in =dired=,
override some keybindings.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :defer t
  :ensure nil
  :config
  (put 'dired-find-alternate-file 'disabled nil)
  :custom
  (dired-listing-switches "-lah --group-directories-first")
  :general
  (wal/major :keymaps 'dired-mode-map
    "e" '(dired-create-empty-file :wk "create empty file"))
  :bind
  (("C-x j" . dired-jump-other-window)
   :map dired-mode-map
   ("." . dired-up-directory) ; Overrides `dired-clean-directory'.
   ("," . dired-display-file)))

;; Use it for dired.
(use-package all-the-icons-dired
  :after all-the-icons
  :diminish
  :hook (dired-mode . all-the-icons-dired-mode))

;; Hit =/= to filter in =dired= buffers.
(use-package dired-filter
  :after dired
  :delight " def")

;; Highlighting in =dired= buffers.
(use-package diredfl
  :after dired
  :config
  (diredfl-global-mode))
#+END_SRC

** Workspace

Everything workspace-related.

*** perspective

Have some perspective, man.

#+BEGIN_SRC emacs-lisp
(defvar wal/default-perspective
  "walheimat"
  "The name of my default perspective.")

(defvar wal/perspective-leader-key "H-i"
  "Leader key for `perspective'.")

(general-create-definer wal/perspective-leader
  :keymaps 'persp-mode-map
  :prefix wal/perspective-leader-key
  :prefix-command 'wal/perspective-command
  :prefix-map 'wal/perspective-map
  :prefix-name "perspective")

(use-package perspective
  :demand
  :custom-face
  (persp-selected-face ((t (:weight bold :foreground "burlywood"))))
  :custom
  (persp-modestring-dividers '("(" ")" "/"))
  (persp-initial-frame-name wal/default-perspective)
  (persp-state-default-file (expand-file-name "persp-persist" wal/cache-directory))
  (persp-mode-prefix-key (kbd "C-c i"))
  :config
  (persp-mode)
  ;; No idea why putting this in `:hook' kills the package.
  (add-hook 'kill-emacs-hook #'persp-state-save)
  :general
  (wal/perspective-leader
    "i" '(persp-switch :wk "switch")
    "k" '(persp-kill-buffer* :wk "kill buffer")
    "n" '(persp-rename :wk "rename")
    "r" '(persp-remove-buffer :wk "remove buffer")
    "a" '(persp-add-buffer :wk "add")))
#+END_SRC

*** projectile

Projects in Emacs.

#+BEGIN_SRC emacs-lisp
(defvar wal/projectile-leader-key "H-p"
  "Leader key for `projectile'.")

(general-create-definer wal/projectile-leader
  :keymaps 'projectile-mode-map
  :prefix wal/projectile-leader-key
  :prefix-command 'wal/projectile-command
  :prefix-map 'wal/projectile-map
  :prefix-name "projectile")

(use-package projectile
  :defer 1
  :delight " pjt"
  :general
  (wal/projectile-leader
    "p" '(projectile-switch-project :wk "switch")
    "f" '(projectile-find-file :wk "find")
    "k" '(projectile-kill-buffers :wk "kill"))
  :custom
  (projectile-completion-system 'ivy)
  (projectile-mode-line-function '(lambda() (format " {%s}" (projectile-project-name))))
  (projectile-switch-project-action #'projectile-dired)
  (projectile-sort-order 'recentf)
  ;; Allow finding files that are ignored by `.gitignore'.
  (projectile-indexing-method 'hybrid)
  (projectile-enable-caching t)
  :config
  (add-to-list 'projectile-globally-ignored-directories "node_modules")
  (add-to-list 'projectile-globally-ignored-directories "build")
  (add-to-list 'projectile-globally-ignored-directories "__pycache__")
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (projectile-mode +1))
#+END_SRC

**** counsel-projectile

Add =counsel= integration to =projectile=.

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :after (projectile counsel)
  :demand
  :custom
  (counsel-projectile-preview-buffers t)
  :config
  ;; Make opening with `dired' the default action.
  (setq counsel-projectile-switch-project-action
        (-replace-at 0 4 counsel-projectile-switch-project-action))
  (counsel-projectile-mode +1)
  :general
  (wal/projectile-leader
     "b" '(counsel-projectile-switch-to-buffer :wk "project buffer"))
  :bind
  (:map projectile-command-map
   ("s s" . counsel-projectile-ag)))
#+END_SRC

** Version Control

I'm becoming an old =git=.

*** magit

Version control has never been this easy before.

#+BEGIN_SRC emacs-lisp
(defun wal/magit-display-buffer-new-frame-status (buffer)
  "Display BUFFER in new frame if it is a status buffer.
Otherwise use `magit-display-buffer-traditional'.
It probably makes sense to bind `q' to `delete-frame'
in `magit-status-mode-map' when using this function."
  (if (eq (with-current-buffer buffer major-mode)
          'magit-status-mode)
        (display-buffer buffer '(display-buffer-pop-up-frame))
    (magit-display-buffer-traditional buffer)))

(use-package magit
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
  (magit-blame-mode-lighter " mbl")
  :bind ("C-c g" . magit-status))
#+END_SRC

**** vdiff-magit

I find =ediff= quite cumbersome, so I'm giving =vdiff= a try.

#+BEGIN_SRC emacs-lisp
(use-package vdiff-magit
  :after magit
  :demand
  :custom
  (vdiff-diff-algorithm 'git-diff)
  (vdiff-magit-stage-is-2way t)
  :config
  ;; `:bind-keymap' doesn't seem to allow mode predicates.
  (define-key vdiff-mode-map (kbd "C-c v") vdiff-mode-prefix-map)
  ;; Add to `magit' dispatch.
  (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
  (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
  (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
  (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit)
  :bind
  (:map vdiff-mode-map
   ("q" . vdiff-quit)
   ("h" . vdiff-hydra/body)
   :map magit-mode-map
   ("e" . vdiff-magit-dwim)
   ("E" . vdiff-magit)))
#+END_SRC

**** magit-todos

#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :after magit
  :custom
  (magit-todos-branch-list nil)
  :bind
  (:map magit-mode-map
   ("," . ivy-magit-todos)
   ("." . magit-todos-list)))
#+END_SRC

*** git-timemachine

If you want to go back in time and point fingers at the progenitors of doom.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :delight " gtm"
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "m" '(git-timemachine-toggle :wk "git-timemachine")))
#+END_SRC

*** gitignore-mode

Syntax highlighting.

Necessary even for =.gitignore= files.

#+BEGIN_SRC emacs-lisp
(defun wal/gitignore-mode ()
  "Hook into `gitignore-mode'."
  (message "I really don't care"))

(use-package gitignore-mode
  :mode ("/\\.npmignore\\'" "/\\.gitignore\\'")
  :hook (gitignore-mode . wal/gitignore-mode))
#+END_SRC

** Languages

Let's greet the world.

*** Elixir

We don't use tabs here.

#+BEGIN_SRC emacs-lisp
(defun wal/elixir-mode ()
  "Hook into `elixir-mode'."
  (message "Mixin' potions")
  (wal/disable-tabs)
  (hack-local-variables)
  (wal/lsp))

(use-package elixir-mode
  :hook (elixir-mode . wal/elixir-mode)
  :general
  (wal/major :keymaps 'elixir-mode-map
    "f" '(elixir-format :wk "format with mode")))
#+END_SRC

*** Python

No tabs here either.
This mode is built-in.

#+BEGIN_SRC emacs-lisp
(defun wal/python-mode ()
  "Hook into `python-mode'."
  (message "Watch out for snakes!")
  (wal/disable-tabs)
  (hack-local-variables)
  (wal/lsp))

(use-package python
  :ensure nil
  :hook (python-mode . wal/python-mode)
  :general
  (wal/major :keymaps 'python-mode-map
    "i" '(run-python :wk "inferior shell")
    "s" '(:ignore t :wk "send")
    "sr" '(python-shell-send-region :wk "region")
    "sb" '(python-shell-send-buffer :wk "buffer")
    "sf" '(python-shell-send-file :wk "file"))
  :config
  ;; Use `python3' as default Python command.
  (setq py-python-command "python3"
        python-shell-interpreter "python3")
  ;; Treat inferior shell as a pop-up.
  (wal/configure-shell-buffer-display 'inferior-python-mode))
#+END_SRC

**** pyvenv

Using virtual envs outside of poetry.

#+begin_src emacs-lisp
(use-package pyvenv
  :general
  (wal/major :keymaps '(dired-mode-map python-mode-map)
    "v" '(pyvenv-activate :wk "activate venv")))
#+end_src

**** poetry

It's like =npm= for Python, it's why it rhymes.

#+BEGIN_SRC emacs-lisp
(defun wal/poetry-pyls ()
  "Make `poetry' work nicely with `pyls'.
If you want to run pyls in poetry using `eglot', be sure
to set your `.dir-locals.el'."
  (unless (fboundp 'poetry-venv-exist-p)
    (require 'poetry))
  (ignore-errors
    (let* ((venv (poetry-venv-exist-p))
           (pyls-exe (file-exists-p (expand-file-name "bin/pyls" venv))))
      (when venv
        (when pyls-exe
          (setq-local lsp-pyls-server-command '("poetry" "run" "pyls")))
        (poetry-venv-workon)))))

(use-package poetry
  :hook (python-mode . wal/poetry-pyls)
  :config
  (wal/configure-shell-buffer-display "\\*poetry-shell\\*")
  :general
  (wal/major :keymaps 'python-mode-map
    "p" '(poetry :wk "poetry")))
#+END_SRC

*** JavaScript

Disable internal checker and definition jumping.

#+BEGIN_SRC emacs-lisp
(defun wal/js2-mode ()
  "Hook into `js2-mode'."
  (message "NaN !== NaN")
  (add-node-modules-path)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (when-let ((eslint (wal/find-local-node-binary "eslint")))
    (setq-local flycheck-javascript-eslint-executable eslint))
  (wal/lsp))

(use-package js2-mode
  :mode "\\.js\\'"
  :config
  (setq-default js2-show-parse-errors nil
                js2-strict-missing-semi-warning nil)
  ;; Remove `js2-jump-to-definition' binding which
  ;; rarely works and gets in the way of `dumb-jump-go'.
  (define-key js2-mode-map (kbd "M-.") nil)
  :hook (js2-mode . wal/js2-mode))
#+END_SRC

**** Node.js

Can we have =deno= instead?

***** add-node-modules-path

Allows accessing a project's =node_modules=.

#+BEGIN_SRC emacs-lisp
(use-package add-node-modules-path
  :defer t)
#+END_SRC

**** TypeScript

Same as JavaScript. But typed.

#+BEGIN_SRC emacs-lisp
(defun wal/typescript-mode ()
  "Hook into `typescript-mode'."
  (message "This is any, that is any, everything is any!")
  (add-node-modules-path)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (when-let ((tslint (wal/find-local-node-binary "tslint")))
    (setq-local flycheck-javascript-eslint-executable tslint))
  (wal/lsp))

(use-package typescript-mode
  :mode "\\.ts\\'"
  :hook (typescript-mode . wal/typescript-mode)
  :general
  (wal/major :keymaps 'typescript-mode-map))
#+END_SRC

**** React/Vue

Pretty much like =js2=.

#+BEGIN_SRC emacs-lisp
(defun wal/rjsx-mode ()
  "Hook into `rjsx-mode'."
  (message "Extend those ugly JavaScripts of yours!")
  (wal/maybe-enable-tabs 'js-jsx-indent-line))

(use-package rjsx-mode
  :mode "\\.jsx\\'"
  :hook (rjsx-mode . wal/rjsx-mode))
#+END_SRC

**** Linting

***** flymake-eslint

ESLint plugin for =flymake=.

#+BEGIN_SRC emacs-lisp
(use-package flymake-eslint
  :after eglot
  :demand
  :hook (eglot-managed-mode . wal/eglot-managed-mode)
  :custom
  (flymake-eslint-defer-binary-check t))
#+END_SRC

***** prettier

Prettify your ugly JavaScript.

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :general
  (wal/major :keymaps '(js2-mode-map typescript-mode-map)
    "p" '(prettier-prettify :wk "run prettier")))
#+END_SRC

***** Loading Local ESLint/TSLint

Use the locally installed =eslint= and =tslint= binaries.

#+BEGIN_SRC emacs-lisp
(defun wal/find-local-node-binary (local-binary)
  "Find LOCAL-BINARY in project's node_modules."
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (bin
          (and root
               (expand-file-name (concat "node_modules/.bin/" local-binary)
                                 root))))
    (when (and bin (file-executable-p bin))
      bin)))
#+END_SRC

*** Lisp

**** emacs-lisp

Enable =flycheck= and disable tabs.

#+BEGIN_SRC emacs-lisp
(defun wal/elisp-mode ()
  "Hook into `emacs-lisp-mode'."
  (message "So it's just a bunch of lists?")
  (wal/disable-tabs)
  (flycheck-mode 1))

(use-package emacs-lisp
  :ensure nil
  :hook (emacs-lisp-mode . wal/elisp-mode))

(use-package highlight-quoted
  :hook (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

*** Web

Does anyone actually like web development?

**** css-mode

We want quicker =company= suggestions when in CSS modes.

#+BEGIN_SRC emacs-lisp
(defun wal/css-mode ()
  "Hook into `css-mode'."
  (message "Centering? It's simple. Here's 15 ways to do it.")
  ;; Faster `company'.
  (setq-local company-idle-delay 0.1)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (flycheck-mode 1))

(use-package css-mode
  :ensure nil
  :hook (css-mode . wal/css-mode))
#+END_SRC

*** Other

Mostly mode configs.

**** yaml-mode

Sometimes you need YAMLs.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :defer t
  :bind
  (:map yaml-mode-map
   ("H-c" . evilnc-comment-or-uncomment-lines)))
#+END_SRC

**** csharp-mode

Unity.

#+BEGIN_SRC emacs-lisp
(defun wal/csharp-mode ()
  "Hook into `csharp-mode'."
  (message "Ouch!")
  (wal/disable-tabs)
  ;; If you're using `lsp-mode' you can run `lsp-install-server'.
  (wal/lsp))

(use-package csharp-mode
  :mode "\\.cs\\'"
  :hook (csharp-mode . wal/csharp-mode))
#+END_SRC

**** cc-mode

I want to be ready for =jai=.
Make sure to install =ccls= and =clang=.

#+BEGIN_SRC emacs-lisp
(defun wal/c++-mode ()
  "Hook into `cc-mode'."
  (message "Make tidy! Make clean!")
  (wal/disable-tabs)
  (wal/lsp))

(use-package cc-mode
  :ensure nil
  :ensure-system-package (ccls clang)
  :config
  ;; Eliminates conflicts with `delight'.
  (advice-add 'c-update-modeline :override #'ignore)
  :hook (c++-mode . wal/c++-mode))
#+END_SRC

**** crontab-mode

It's time to deal with this.

#+BEGIN_SRC emacs-lisp
(use-package crontab-mode
  :defer t)
#+END_SRC

**** nginx-mode

Make nginx configuration files look pretty.

#+BEGIN_SRC emacs-lisp
(use-package nginx-mode
  :defer t
  :config
  (add-to-list 'auto-mode-alist
               '("/nginx/sites-\\(?:available\\|enabled\\)/" . nginx-mode)))
#+END_SRC

**** markdown-mode

Markdown. Sometimes you need it.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :defer t)
#+END_SRC

**** lua-mode

Why not. It can be /awesome/.

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :defer t)
#+END_SRC

**** json-mode

Enable tabs and =flycheck=.

#+BEGIN_SRC emacs-lisp
(defun wal/json-mode ()
  "Hook into `json-mode'."
  (message "JSON ...? JSON?! JSON!!")
  (rainbow-delimiters-mode)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (flycheck-mode 1))

(use-package json-mode
  :hook (json-mode . wal/json-mode))
#+END_SRC

**** go-mode

Setup for LSP.

#+BEGIN_SRC emacs-lisp
(defun wal/go-mode ()
  "Hookp into `go-mode'."
  (message "What does Sonic say?")
  (wal/disable-tabs)
  (hack-local-variables)
  (wal/lsp))

(use-package go-mode
  :hook (go-mode . wal/go-mode))
#+END_SRC

**** haskell-mode

Don't use Haskell much yet.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :defer t)
#+END_SRC

**** pug-mode

Support for =pug= templates.

#+begin_src emacs-lisp
(use-package pug-mode
  :defer t)
#+end_src

**** fish-mode

Support for =fish= functions.

#+begin_src emacs-lisp
(use-package fish-mode
  :defer t)
#+end_src

** LSP

Language servers are awesome. Thanks, Microsoft.

#+BEGIN_SRC emacs-lisp
(defvar wal/lsp-client 'eglot
  "Which lsp client to use.")

(defun wal/lsp ()
  "Activate lsp client."
  (pcase wal/lsp-client
    ('lsp-mode (lsp-deferred))
    ('eglot (progn
              (eglot-ensure)
              (yas-minor-mode)))
    (_ nil)))
#+END_SRC

*** lsp-mode

This is the fancy version.

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :delight " lsp"
  :hook (lsp-mode . flycheck-mode)
  :bind-keymap
  ("C-c l" . lsp-command-map) ; Setting `lsp-keymap-prefix' doesn't work.
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "l" '(lsp-mode :wk "lsp"))
  (wal/captain :keymaps 'lsp-mode-map
    "l" '(:ignore t :wk "lsp")
    "lr" '(lsp-rename :wk "rename symbol")
    "lf" '(lsp-format-buffer :wk "format buffer"))
  :custom
  (lsp-completion-provider :capf)
  (lsp-prefer-capf t)
  (lsp-idle-delay 1.5)
  ;; These have to be defined here.
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-log-io t)
  ;; Enable `pylint'.
  (lsp-pyls-plugins-pylint-enabled t)
  (lsp-pyls-plugins-jedi-use-pyenv-environment t)
  :config
  (lsp-enable-which-key-integration t)
  ;; Ignore elixir build and dependency folders.
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]_build$")
  (add-to-list 'lsp-file-watch-ignored "[/\\\\]deps$"))

(use-package lsp-ui
  :after lsp-mode
  :custom
  (lsp-ui-sideline-delay 5)
  (lsp-ui-doc-position 'top) ; Alternatively `at-point'.
  (lsp-ui-doc-delay 2))
#+END_SRC

**** dap-mode

Debugging using VSCode's DAP.
Since this only works with =lsp-mode=, I consider
it a sub-package of it.

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :delight " dap"
  :custom
  (dap-python-executable "python3")
  ;; Be sure to install with `pip3'.
  (dap-python-debugger 'debugpy)
  (dap-print-io t)
  (dap-auto-configure-features '(repl))
  ;; (dap-python-terminal "sudo ")
  :config
  (dap-ui-mode 1)
  (require 'dap-node)
  (require 'dap-python)
  (wal/configure-shell-buffer-display 'dap-ui-repl-mode)
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "d" '(dap-mode :wk "dap"))
  (wal/captain :keymaps 'dap-mode-map
    "d" '(dap-hydra :wk "dap")))
#+END_SRC

***** Debug Templates

Put these templates in a file in your project root,
and evaluate them there using =C-x C-e=.

****** Node.js

This for attaching to a remote host (Docker container) using =nodemon=.

For TypeScript compile your =src= with =--sourceMap= or set =sourceMap=
to =true= in your =tsconfig.json=.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (progn
    (let* ((use-source-maps t) ; Turn off if not needed.
           (build-directory "build") ; Set to `nil' if this isn't transpiled JavaScript.
           (remote-root "/usr/src/app") ; If this is running remotely.
           (local-root (if build-directory
                           (concat (file-name-directory buffer-file-name) build-directory)
                         (file-name-directory buffer-file-name))))
      (dap-register-debug-template
       "attach::node"
       (list :type "node"
             :request "attach"
             :sourceMaps use-source-maps
             :remoteRoot remote-root
             :localRoot local-root
             :port 9229)))))
#+END_SRC

****** Python

Attach to running process.

#+BEGIN_SRC emacs-lisp :tangle no
;; Adapt your remote root
(when (require 'dap-mode nil 'noerror)
  (let ((mapping '(:localRoot "${workspaceFolder}" :remoteRoot "/usr/src/app")))
    (dap-register-debug-template
     "python::attach"
     (list :type "python"
           :request "attach"
           :connect (list :host "localhost" :port 5678)
           :pathMappings (vector mapping)))))
#+END_SRC

*** eglot

This is the light-weight alternative.

#+BEGIN_SRC emacs-lisp
(defun wal/eglot-managed-mode ()
  "Hook into `eglot-managed-mode-hook'."
  (pcase major-mode
    ((or 'js2-mode 'rjsx-mode)
     (if (eglot-managed-p)
         (add-hook 'flymake-diagnostic-functions 'flymake-eslint--checker nil t)
       (remove-hook 'flymake-diagnostic-functions 'flyamke-eslint--checker t)))
    (_ nil)))

;; `eglot' uses `eldoc' extensively.
(use-package eldoc
  :ensure nil
  :defer t
  :diminish " eld")

(use-package eglot
  :general
  (wal/captain :keymaps 'eglot-mode-map
    "l" '(:ignore t :wk "eglot")
    "lc" '(eglot-reconnect :wk "reconnect")
    "lf" '(eglot-format :wk "format")
    "lr" '(eglot-rename :wk "rename")
    "ls" '(eglot-shutdown :wk "shutdown")
    "la" '(eglot-code-actions :wk "code actions")))
#+END_SRC

**** Server Configurations

Configure or register language servers that aren't as straight forward.
You will have to install them yourself[fn:11].

=eglot= prefers using a =.dir-locals.el= file to configure
a language server.

***** Elixir

#+BEGIN_SRC emacs-lisp
;;; Elixir:
(defvar elixir-ls-release-location
  (expand-file-name "ls/elixir" user-emacs-directory)
  "Location of the Elixir language server.")

;; Add executable to path.
(when (file-exists-p (expand-file-name "language_server.sh" elixir-ls-release-location))
  (add-to-list 'exec-path elixir-ls-release-location))
#+END_SRC


***** =pylint=

This one assumes you want to enable =pylint= and you're
using =poetry=.

#+BEGIN_SRC emacs-lisp :tangle no
((python-mode
  . ((eglot-workspace-configuration
      . ((pyls . ((plugins (pylint (enabled . t)))
                  (executable  . "poetry run pyls"))))))))
#+END_SRC

***** =gopls=

Taken from the official documentation.

#+BEGIN_SRC emacs-lisp :tangle no
((go-mode
  . ((eglot-workspace-configuration
      . ((gopls . ((staticcheck . t)
                    (matcher . "CaseSensitive"))))))))
#+END_SRC

***** prolog

Using =swipl=.

#+begin_src emacs-lisp
(with-eval-after-load 'lsp-mode
  (lsp-register-client
   (make-lsp-client
    :new-connection
    (lsp-stdio-connection (list "swipl"
                                "-g" "use_module(library(lsp_server))."
                                "-g" "lsp_server:main"
                                "-t" "halt"
                                "--" "stdio"))
    :major-modes '(prolog-mode)
    :priority 1
    :multi-root t
    :server-id 'prolog-ls)))
#+end_src

** Windows

Everything that has to do with windows.

*** ace-window

=ace-window= allows for some nifty window swapping.

#+BEGIN_SRC emacs-lisp
(defun wal/aw-delete-window-kill-buffer (window)
  "Call `aw-delete-window' on WINDOW requesting buffer kill."
  (aw-delete-window window t))

(use-package ace-window
  :delight " ace"
  :custom
  (aw-fair-aspect-ratio 4)
  (aw-dispatch-always t)
  (aw-keys '(?j ?k ?l ?\; ?u ?i ?o ?p))
  :config
  (setq aw-dispatch-alist '((?h aw-split-window-horz "horizontal split")
                            (?v aw-split-window-vert "vertical split")
                            (?d aw-delete-window "delete")
                            (?x wal/aw-delete-window-kill-buffer "kill")
                            (?w delete-other-windows "delete other")
                            (?s aw-swap-window "swap")
                            (?m aw-move-window "move")
                            (?b aw-switch-buffer-in-window "switch focused")
                            (?o aw-switch-buffer-other-window "switch unfocused")
                            (?f aw-split-window-fair "fair split")
                            ;; If this has a description, it doesn't work.
                            (?? aw-show-dispatch-help)))
  ;; Use our custom `switch-buffer' function.
  (advice-add 'aw--switch-buffer
              :override (lambda (&rest r) (wal/switch-buffer r))
              '((name . "aw--switch-buffer")))
  :bind
  ("H-w" . ace-window))
#+END_SRC

*** golden-ratio

Use the golden ratio.

#+BEGIN_SRC emacs-lisp
(defun wal/aw-switch-maybe-golden-ratio (_window)
  "Invoke `golden-ratio' if mode is active.
Used to advise `aw-switch-to-window'."
  (when (eq golden-ratio-mode t)
    (golden-ratio)))

(use-package golden-ratio
  :delight " gol"
  :config
  ;; Make sure to run golden ratio after `aw-switch-to-window'.
  (advice-add 'aw-switch-to-window :after #'wal/aw-switch-maybe-golden-ratio)
  :general
  (wal/colonel "g" '(golden-ratio-mode :wk "golden ratio"))
  (wal/captain "g" '(golden-ratio :wk "golden ratio")))
#+END_SRC

*** popper

Be a =winner= without the mode.

#+BEGIN_SRC emacs-lisp
(defun wal/popper-toggle ()
  "Toggle latest or cycle when focusing pop-up."
  (interactive)
  (if (popper-popup-p (current-buffer))
      (popper-cycle)
    (popper-toggle-latest)))

(defun wal/popper-open-all ()
  "Same as `popper-open-all' but interactive."
  (interactive)
  (popper-open-all))

(use-package popper
  :after perspective
  :defer 1
  :bind
  (:map popper-mode-map
   ("H-e" . popper-toggle-latest)
   ("H-E" . popper-cycle))
  :general
  (wal/captain "e" '(:ignore t :wk "popper")
    "er" '(popper-toggle-type :wk "raise or drop")
    "ek" '(popper-kill-latest-popup :wk "kill latest")
    "ea" '(wal/popper-open-all :wk "open all"))
  :custom
  (popper-reference-buffers '("\\*poetry-shell\\*"
                              "^\\*docker-compose"
                              "\\*Bookmark Annotation\\*"
                              "\\*eldoc\\*"
                              org-agenda-mode
                              docker-container-mode
                              inferior-python-mode
                              ag-mode
                              helpful-mode
                              help-mode
                              debugger-mode
                              dap-ui-repl-mode
                              shell-mode))
  (popper-group-function #'popper-group-by-perspective)
  (popper-display-control 'user)
  ;; Remove if you don't use/have `doom-modeline'.
  (popper-mode-line '(:eval (concat
                             " "
                             (doom-modeline-icon 'faicon "fort-awesome" nil nil
                                                 :face 'all-the-icons-dsilver
                                                 :height 0.9
                                                 :v-adjust 0.0)
                             " ")))
  :config
  (winner-mode 1)
  (popper-mode +1))
#+END_SRC

** Editing

It's fun to edit things /quickly/.

*** multiple-cursors

Don't you want to edit your buffer in multiple places at once?

#+BEGIN_SRC emacs-lisp
(defvar wal/mc-leader-key "H-c"
  "Leader key for `multiple-cursors'.")

(general-create-definer wal/mc-leader
  :prefix wal/mc-leader-key
  :prefix-command 'wal/mc-command
  :prefix-map 'wal/mc-map
  :prefix-name "multiple cursors")

(use-package multiple-cursors
  :init
  ;; Since the map is `nil', using `:bind' would fail.
  (setq mc/keymap (make-sparse-keymap))
  :general
  (wal/mc-leader
    "c" '(mc/mark-all-like-this :wk "all like this")
    "b" '(mc/edit-beginnings-of-lines :wk "beginnings")
    "e" '(mc/edit-ends-of-lines :wk "end"))
  :bind
  (("H-<mouse-3>" . mc/add-cursor-on-click)
   ("C-." . mc/mark-next-like-this)
   :map mc/keymap
   ("C-g" . mc/keyboard-quit) ; We keep this from the default map.
   ("C-," . mc/unmark-next-like-this)
   ("C-/" . mc/skip-to-next-like-this)))
#+END_SRC

*** crux

Let's use =crux= for some editing magic.
Check the [[*Key Bindings][key bindings section]] for descriptions.

#+BEGIN_SRC emacs-lisp
(use-package crux
  :general
  (wal/general
    "ci" '(crux-find-user-init-file :wk "init file")
    "or" '(crux-rename-file-and-buffer :wk "rename file and buffer")
    "os" '(crux-sudo-edit :wk "sudo edit"))
  :bind
  (("M-o" . crux-other-window-or-switch-buffer)
   ("H-d" . crux-duplicate-current-line-or-region)
   ("C-S-k" . crux-kill-line-backwards)
   ("C-k" . crux-smart-kill-line)
   ("C-o" . crux-smart-open-line)
   ("C-S-o" . crux-smart-open-line-above)))
#+END_SRC

*** expand-region

One thing that can be a bit tricky is selecting regions, not anymore.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  (("C->" . er/expand-region)
   ("C-<" . er/contract-region)))
#+END_SRC

*** evil-nerd-commenter

Comment code like in =vim=, evil, evil =vim=.

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :bind
  (:map prog-mode-map
   ("H-c" . evilnc-comment-or-uncomment-lines)))
#+END_SRC

*** undo-fu

Undoing un-undoing is weird in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package undo-fu
  :bind (("C-/" . undo-fu-only-undo)
         ("C-?" . undo-fu-only-redo)))
#+END_SRC

*** yasnippet

Use snippets in =prog= mode buffers.
Because I also use company, =yas-expand= is mapped to =H-<TAB>=,
if you don't have a hyper key, bind it to a personal binding.

#+BEGIN_SRC emacs-lisp
(defun wal/yas-expand ()
  "Fix `yas-expand' within `org-mode'."
  (interactive)
  (let ((org-src-tab-acts-natively nil)
        (org-adapt-indentation nil))
    (yas-expand)))

(use-package yasnippet
  :delight " yas"
  :hook
  ;; During snippet expansion, we don't want `company' to intefere.
  ((yas-before-expand-snippet . (lambda ()
                                  (when (derived-mode-p 'prog-mode)
                                    (company-mode -1))))
   (yas-after-exit-snippet . (lambda ()
                               (when (derived-mode-p 'prog-mode)
                                 (company-mode +1)))))
  :general
  (wal/colonel "y" '(yas-minor-mode :wk "yasnippet"))
  (wal/captain :keymaps 'yas-minor-mode-map
    "y" '(:ignore t :wk "yasnippet")
    "yv" '(yas-visit-snippet-file :wk "visit snippet file")
    "yc" '(yas-new-snippet :wk "create new snippet"))
  :bind
  (:map yas-minor-mode-map
   ("H-<tab>" . #'wal/yas-expand))
  :config
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (yas-reload-all))

(use-package yasnippet-snippets
  :after yasnippet)
#+END_SRC

*** smartparens

I didn't have smart parens growing up so I need help.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish smartparens-mode
  :hook (prog-mode . smartparens-mode)
  :config
  ;; Only require configs that I want.
  (require 'smartparens-python)
  (add-to-list 'sp-lisp-modes 'lisp-data-mode)
  (sp-with-modes sp-lisp-modes
    ;; disable ', it's the quote character!
    (sp-local-pair "'" nil :actions nil))
  :general
  (wal/captain :keymaps 'smartparens-mode-map
    "p" '(:ignore t :wk "smartparens")
    "pr" '(sp-rewrap-sexp :wk "rewrap")
    "pk" '(sp-kill-sexp :wk "kill")
    "pf" '(sp-forward-sexp :wk "forward")
    "pb" '(sp-backward-sexp :wk "backward")))
#+END_SRC

*** drag-stuff

Use the default key bindings.

#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :delight " drg"
  :hook (prog-mode . drag-stuff-mode)
  :config
  (drag-stuff-define-keys))
#+END_SRC

*** hungry-delete

I know you're hiding that sweet, sweet whitespace
in that basket, Little Red Riding Hood!

#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :delight " hun"
  :custom
  (hungry-delete-join-reluctantly t)
  :general
  (wal/colonel :keymaps '(prog-mode-map org-mode-map)
    "h" '(hungry-delete-mode :wk "hungry delete")))
#+END_SRC

** Movement

Moving around should be fun.

*** avy

Jumping to (visible) lines and chars is fun if you are too lazy to use your mouse.

#+BEGIN_SRC emacs-lisp
(defun wal/avy-goto-line-and-char ()
  "Go to line and then to char in line.
Just goes to line if line is empty."
  (interactive)
  (avy-goto-line)
  (let ((line-length (save-excursion (end-of-line) (current-column))))
    (unless (zerop line-length)
      (let ((char (read-char "char: " t)))
        (avy-goto-char-in-line char)))))

(defvar wal/avy-leader-key "H-l"
  "Leader key for `avy' actions.")

(general-create-definer wal/avy-leader
    :prefix wal/avy-leader-key
    :prefix-command 'wal/avy-command
    :prefix-map 'wal/avy-map
    :prefix-name "avy")

(use-package avy
  :config
  :general
  (wal/avy-leader
    "l" '(avy-goto-line :wk "go to line")
    "c" '(avy-goto-char :wk "go to char")
    "w" '(avy-copy-line :wk "copy line")
    "r" '(avy-copy-region :wk "copy region")
    "m" '(avy-move-line :wk "move line")
    "e" '(avy-goto-whitespace-end :wk "go to whitespace end")
    "k" '(avy-kill-whole-line :wk "kill line")
    "b" '(wal/avy-goto-line-and-char :wk "go to line and char")))
#+END_SRC

*** mwim

Move where I want.
Useful for comments.

#+BEGIN_SRC emacs-lisp
(use-package mwim
  :bind
  (("C-a" . mwim-beginning)
   ("C-e" . mwim-end)))
#+END_SRC

*** consult

More useful replacements and extensions.
We have do advise some of the functions to play
nice despite us using =ivy= for completion everywhere.

#+BEGIN_SRC emacs-lisp
(use-package consult
  :custom
  (consult-project-root-function #'projectile-project-root)
  :bind
  (("M-g g" . consult-goto-line)
   ("M-g m" . consult-mark)
   ("M-g M-m" . consult-global-mark))
  :config
  ;; Advise functions to use selectrum when `ivy' behaves unpredictably.
  (--each
      '(consult-buffer
        consult-focus-lines
        consult-flymake
        consult-global-mark
        consult-grep
        consult-mark
        consult-minor-mode-menu
        consult-mode-command
        consult-outline)
    (advice-add it :around #'wal/advise-selectrum))
  :general
  (wal/major "c" '(consult-mode-command :wk "invoke mode command"))
  (wal/major :keymaps 'org-mode-map
    "j" '(consult-outline :wk "jump to heading"))
  (wal/general "ol" '(consult-focus-lines :wk "focus lines")))

(use-package consult-flycheck
  :after (consult flycheck)
  :config
  (advice-add 'consult-flycheck :around #'wal/advise-selectrum))
#+END_SRC

*** smooth-scrolling

Smooth scrolling at the margins using =C-n= and =C-p=.

#+BEGIN_SRC emacs-lisp
(use-package smooth-scrolling
  :defer 2
  :custom
  (smooth-scroll-margin 4)
  :config
  (smooth-scrolling-mode 1))
#+END_SRC

** Finding Things

I mostly search.

*** ag

Highlight search results using the *Silver Searcher*.

This _requires_ the =ag= binary which you can get from [[https://github.com/ggreer/the_silver_searcher#installation][here]] (we will try
to download it automatically, but might fail).

#+BEGIN_SRC emacs-lisp
(defvar wal/ag-leader-key "H-s"
  "Leader key for `ag'.")

(general-create-definer wal/ag-leader
  :prefix wal/ag-leader-key
  :prefix-command 'wal/ag-command
  :prefix-map 'wal/ag-map
  :prefix-name "ag")

(use-package ag
  :config
  (wal/configure-result-buffer-display 'ag-mode)
  :ensure-system-package ag
  :custom
  (ag-highlight-search t)
  (ag-reuse-buffers t)
  ;; Include hidden files. We ignore only specific dirs.
  (ag-arguments '("--smart-case" "--stats" "--hidden"))
  (ag-ignore-list '(".git"
                    ".idea"
                    ".ccls-cache"
                    ".vscode"
                    "node_modules"
                    "coverage"
                    "deps"
                    "dist"
                    "build"
                    "*.svg"))
  :general
  (wal/ag-leader
    "s" '(ag :wk "default")
    "t" '(ag-files :wk "by file-type")
    "p" '(ag-project :wk "in project")
    "f" '(ag-dired :wk "for file")))
#+END_SRC

*** ctrlf

Replacement for =isearch=.
Important command is =C-o c= to change search style.

#+BEGIN_SRC emacs-lisp
(use-package ctrlf
  :defer 1
  :custom
  (ctrlf-auto-recenter t)
  ;; Not relased yet.
  (ctrlf-go-to-end-of-match nil)
  :config
  ;; Prefer fuzzy over literal.
  ;; Can't defer if this is part of `:custom'.
  (setq ctrlf-mode-bindings '(("C-s" . ctrlf-forward-fuzzy)
                              ("C-r" . ctrlf-backward-fuzzy)
                              ("M-s" . ctrlf-forward-literal)
                              ("M-r" . ctrlf-backward-literal)))
  (ctrlf-mode +1))
#+END_SRC

*** dumb-jump

Jump to definitions (in other files).
Configure it for =ivy= and =ag=.
Jumping is done using =xref-find-definitions= (=M-.=).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :defer t
  :custom
  (dumb-jump-selector 'ivy)
  (dumb-jump-force-searcher 'ag)
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

** Terminal

#+BEGIN_QUOTE
I am convinced that we are in a terminal process.
— E. P. Thompson
#+END_QUOTE

*** vterm

=vterm= can be an alternative to included shells.
We also install =vterm-toggle=.
Also, if you're on an older Ubuntu version (like my work PC),
the =libvterm= package might be too old, but you could
always try to build from source ...

#+BEGIN_SRC emacs-lisp
(defun wal/vterm-mode ()
  "Adjustments for `vterm'."
  (ctrlf-local-mode -1))

(unless (version< emacs-version "27.0")
  (use-package vterm
    :hook (vterm-mode . wal/vterm-mode)
    :delight
    (vterm-copy-mode " vcp")
    :custom
    (vterm-kill-buffer-on-exit t)
    :config
    (when (file-exists-p "/bin/fish")
      (setq vterm-shell "/bin/fish")))

  (use-package vterm-toggle
    :custom
    (vterm-toggle-fullscreen-p nil)
    (vterm-toggle-scope 'project)
    :config
    (wal/configure-shell-buffer-display 'vterm-mode)
    :bind
    ("H-t" . vterm-toggle)))
#+END_SRC

**** =vterm= Key Bindings

Some common shell commands require an additional =C-c=:

+ =C-c C-c= to send =C-c=.
+ =C-c C-g= to send =C-g=.
+ =C-c C-u= to send =C-u=.
+ =C-c C-t= to enter/exit =copy-mode=.

*** eshell

Set up =eshell=.
I like the idea of it but I don't really use it.

#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode))

(use-package eshell-prompt-extras
  :after eshell
  :config
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-lambda))

(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))

(use-package eshell
  :ensure nil
  :config
  ;; Override how clearing the eshell works.
  (advice-add
   'eshell/clear :override
   (lambda nil
     (let ((eshell-buffer-maximum-lines 0))
       (eshell-truncate-buffer))))
  (wal/configure-shell-buffer-display 'eshell-mode)
  :general
  (wal/general "e" '(eshell :wk "eshell"))
  :bind
  (:map eshell-mode-map
   ([remap eshell-pcomplete] . completion-at-point)))
#+END_SRC

** Completion

You complete me.

*** ivy

We use =ivy= for narrowing our options.

#+BEGIN_SRC emacs-lisp
(defun wal/ivy-switch-ignored-buffers (&rest r)
  "Show only commonly ignored buffers.
Pass R to the switch buffer function."
  (interactive)
  (let ((ivy-ignore-buffers
         '((lambda (buffer-or-string)
             (not (wal/commmonly-ignored-buffer-p buffer-or-string))))))
    (wal/switch-buffer r)))

;; Change to ivy-switch-buffer if you don't use perspective.
(defalias 'wal/switch-buffer 'persp-counsel-switch-buffer)

;; Hide `dired', `docker', `ag' and default Emacs buffers when switching.
(defvar wal/ivy-ignore-buffers
  '(wal/commmonly-ignored-buffer-p
    "\\` "
    "\\`\\*tramp/")
  "The buffers I don't want to see unless I have to.")

;; Toggle custom ignore on or off.
(defun wal/query-ivy-ignore ()
  "Query if custom ivy buffer ignore list should be used."
  (interactive)
  (if (y-or-n-p "Use custom ivy buffer ignore? ")
      (setq ivy-ignore-buffers wal/ivy-ignore-buffers)
    (setq ivy-ignore-buffers '("\\` " "\\`\\*tramp/"))))

(use-package ivy
  :defer 1
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-ignore-buffers wal/ivy-ignore-buffers)
  (ivy-count-format "%d/%d ")
  (ivy-wrap t)
  :config
  (setq enable-recursive-minibuffers t)
  (ivy-mode 1)
  :general
  (wal/captain "i" '(:ignore t :wk "ivy")
    "ir" '(ivy-resume :wk "resume"))
  :bind
  (:map ivy-mode-map
   ("C-x b" . wal/switch-buffer)
   ("C-x C-b" . wal/ivy-switch-ignored-buffers))) ; Replaces `list-buffers'.
#+END_SRC

**** ivy-avy

Using =avy= inside =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package ivy-avy
  :after ivy
  :bind
  (:map ivy-minibuffer-map
   ("H-l" . ivy-avy)))
#+END_SRC

**** ivy-rich

Some nicer candidate view when switching buffers.

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :after ivy
  :defer 1
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-rich-mode 1))

(use-package all-the-icons-ivy-rich
  :after (all-the-icons ivy-rich counsel projectile counsel-projectile)
  :config
  ;; Prettify two more functions.
  (plist-put all-the-icons-ivy-rich-display-transformers-list 'counsel-projectile-switch-to-buffer
           '(:columns
            ((all-the-icons-ivy-rich-file-icon)
             (ivy-rich-candidate))
            :delimiter "\t"))
  (plist-put all-the-icons-ivy-rich-display-transformers-list 'persp-kill-buffer*
           '(:columns
            ((all-the-icons-ivy-rich-file-icon)
             (ivy-rich-candidate))
            :delimiter "\t"))
  (all-the-icons-ivy-rich-mode 1)
  ;; The following binding is trashed by `all-the-icons-ivy-rich-kill-buffer'.
  (global-set-key (kbd "C-x C-k") 'kmacro-keymap))
#+END_SRC

*** counsel

=counsel= me this, Counselor.

#+BEGIN_SRC emacs-lisp
;; `prescient' is defined later, so we have to define it here.
(defvar wal/use-prescient t
  "Whether `prescient' is used.")

(use-package counsel
  :after ivy
  :demand
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-command-only)
  :config
  ;; Package ivy-prescient sets `ivy-initial-inputs-alist' to nil!
  (unless wal/use-prescient
    (setcdr (assq 'counsel-M-x ivy-initial-inputs-alist) ""))
  ;; Any theme set by `counsel-load-theme' should also set
  ;; `wal/*-theme' so that calling `wal/light-switch' doesn't
  ;; undo things.
  (advice-add
   'counsel-load-theme :filter-return
   (lambda (theme)
     (if (eq wal/primary-emacs-theme wal/active-theme)
         (setq wal/primary-emacs-theme (intern theme))
       (setq wal/secondary-emacs-theme (intern theme)))
     (setq wal/active-theme (intern theme)))
   '((name . "counsel-load-theme")))
  :general
  (wal/general
    "t" '(counsel-load-theme :wk "load theme")
    "h" '(counsel-command-history :wk "show command history")
    "l" '(counsel-find-library :wk "find library")
    "v" '(counsel-set-variable :wk "set variable")
    "og" '(counsel-search :wk "duck-duck-go"))
  :bind
  (:map ivy-mode-map
   ("C-x B" . counsel-switch-buffer)
   ("M-x" . counsel-M-x)
   ("<menu>" . counsel-M-x)
   ("C-x C-f" . counsel-find-file)))
#+END_SRC

*** company

Code-completion.
In a box.

#+BEGIN_SRC emacs-lisp
(use-package company
  :delight " cmp"
  :general
  (wal/colonel :keymaps '(prog-mode-map dap-ui-repl-mode-map)
    "c" '(company-mode :wk "company"))
  :custom
  (company-minimum-prefix-length 2)
  :hook (prog-mode . company-mode))

(use-package company-box
  :diminish
  :hook (company-mode . company-box-mode))
#+END_SRC

*** prescient

Better short-term-memory for =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package prescient
  :after counsel
  :if wal/use-prescient
  :custom
  (prescient-sort-length-enable nil)
  (prescient-save-file (expand-file-name "prescient-persist" wal/cache-directory))
  (prescient-filter-method '(literal regexp initialism))
  :config
  (prescient-persist-mode +1))

(use-package ivy-prescient
  :if wal/use-prescient
  :after (counsel prescient)
  :custom
  ;; Default plus `wal/switch-buffer'.
  (ivy-prescient-sort-commands '(:not swiper swiper-isearch ivy-switch-buffer wal/switch-buffer))
  (ivy-prescient-retain-classic-highlighting t)
  :config
  (ivy-prescient-mode +1))
#+END_SRC

*** selectrum

A potential =ivy= replacement.
Sunken cost thinking prevents a switch for now
but we still use it to advise a few =consult= functions.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-selectrum(func &rest r)
  "Call FUNC applying R using `selectrum' for read completion."
  (let ((completing-read-function #'selectrum-completing-read)
        (read-buffer-function #'selectrum-read-buffer)
        (read-file-name-function #'selectrum-read-file-name)
        (complete-in-region-function #'selectrum-complete-in-region)
        (read-libary-name #'selectrum-read-libarary-name)
        (completion-styles '(substring partial-completion)))
    (apply func r)))

(use-package selectrum
  :defer t)
#+END_SRC

** Fixing

Please let me know when I screwed up.
I promise I will learn.

#+BEGIN_SRC emacs-lisp
(defun wal/fly-check ()
  "Call either `consult-flymake' or `consult-flycheck'.
This depends on `wal/lsp-client'."
  (interactive)
  (cond (flycheck-mode (consult-flycheck))
        (flymake-mode (consult-flymake))
        (t nil)))

(wal/captain :keymaps '(flymake-mode-map flycheck-mode-map)
  "f" '(wal/fly-check :wk "fly-check"))
#+END_SRC

*** flymake

Built-in syntax checker. Used by =eglot=.

#+BEGIN_SRC emacs-lisp
(use-package flymake
  :ensure nil
  :defer t
  :config
  (advice-add 'flymake--mode-line-title
              :override (lambda () "flm")
              '((name . "flymake--mode-line-title"))))
#+END_SRC

*** flycheck

=flycheck= is for all of our linting/code quality needs.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :defer t
  :delight " fly"
  :custom
  (flycheck-keymap-prefix (kbd "C-c f"))
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "f" '(flycheck-mode :wk "flycheck")))
#+END_SRC

**** Finding ESLint

ESLint configs can be found using a file, not a directory.

#+BEGIN_SRC emacs-lisp
(defun flycheck-eslint-config-exists-p ()
  "Whether there is a valid eslint config for the current buffer."
  (let* ((executable (flycheck-find-checker-executable 'javascript-eslint))
         (exitcode (and executable (call-process executable
                                                 nil
                                                 nil
                                                 nil
                                                 "--print-config"
                                                 ".eslintrc"))))
    (eq exitcode 0)))
#+END_SRC

**** Fix =pylint= False Positives

The =pylint= checker creates false positives for
relative import mistakes. There is a fix but it doesn't seem
to be released yet.
Taken from [[https://github.com/bkhl/flycheck/commit/3f9582d2df42d4f55ee1fc33aae1a56bf1dab421][here]].

#+BEGIN_SRC emacs-lisp
(defun flycheck-pylint-find-project-root (_checker)
  "Find the directory to invoke pylint from.

The algorithm is the same as used by epylint: find the first
directory that doesn't have a __init__.py file."
  (locate-dominating-file
   (if buffer-file-name
       (file-name-directory buffer-file-name)
     default-directory)
   (lambda (dir)
     (not (file-exists-p (expand-file-name "__init__.py" dir))))))

(flycheck-define-checker python-pylint
  "A Python syntax and style checker using Pylint.

This syntax checker requires Pylint 1.0 or newer.

See URL `https://www.pylint.org/'."
  :command ("python3"
            (eval (flycheck-python-module-args 'python-pylint "pylint"))
            "--reports=n"
            "--output-format=json"
            (config-file "--rcfile=" flycheck-pylintrc concat)
            source-inplace)
  :error-parser flycheck-parse-pylint
  :enabled (lambda ()
             (or (not (flycheck-python-needs-module-p 'python-pylint))
                 (flycheck-python-find-module 'python-pylint "pylint")))
  :verify (lambda (_) (flycheck-python-verify-module 'python-pylint "pylint"))
  :error-explainer (lambda (err)
                     (-when-let (id (flycheck-error-id err))
                       (apply
                        #'flycheck-call-checker-process-for-output
                        'python-pylint nil t
                        (append
                         (flycheck-python-module-args 'python-pylint "pylint")
                         (list (format "--help-msg=%s" id))))))
  :working-directory flycheck-pylint-find-project-root
  :modes python-mode
  :next-checkers ((warning . python-mypy)))
#+END_SRC

*** flyspell

My spelling is bad.
Use American English for =flyspell=.
You can bring up actions (skip, save) with =M-o=.

#+BEGIN_SRC emacs-lisp
(defun wal/flyspell-prog-mode ()
  "Toggle function `flyspell-prog-mode' properly."
  (interactive)
  (if flyspell-mode
      (flyspell-mode -1)
    (flyspell-prog-mode)))

(defun wal/flyspell-mode ()
  "Toggle function `flyspell-mode' properly."
  (interactive)
  (if flyspell-mode
      (flyspell-mode -1)
    (flyspell-mode 1)))

(use-package flyspell
  :ensure nil
  :delight " fsp"
  :custom
  (flyspell-issue-message-flag nil)
  :config
  (setq ispell-dictionary "american")
  :general
  (wal/colonel :keymaps '(text-mode-map org-mode-map)
    "s" '(wal/flyspell-mode :wk "flyspell"))
  (wal/colonel :keymaps 'prog-mode-map
    "s" '(wal/flyspell-prog-mode :wk "flyspell-prog"))
  (wal/captain :keymaps 'flyspell-mode-map
    "s" '(flyspell-buffer :wk "spell-check buffer")))

(use-package flyspell-correct
  :after flyspell
  :bind
  (:map flyspell-mode-map
   ("C-/" . flyspell-correct-at-point)))

(use-package flyspell-correct-ivy
  :after flyspell-correct)
#+END_SRC

** Visuals

I like nice-looking things.

*** Themes

**** doom-themes

One of the nicest theme packages out there.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :defer t
  :config
  (doom-themes-org-config))
#+END_SRC

**** humanoid-themes

Very colorful.

#+begin_src emacs-lisp
(use-package humanoid-themes
  :defer t)
#+end_src

**** kaolin-themes

This is a themes collection I sometimes pick from.

#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :defer t
  :custom
  ;; (kaolin-ocean-alt-bg t)
  (kaolin-themes-italic-comments t)
  (kaolin-themes-git-gutter-solid t)
  ;; Remove that `modeline' border.
  (kaolin-themes-modeline-border nil)
  ;; Distinct background for fringe and line numbers.
  (kaolin-themes-distinct-fringe t)
  ;; Distinct colors for company popup scrollbar.
  (kaolin-themes-distinct-company-scrollbar t)
  :config
  ;; Some packages use `treemacs'.
  (kaolin-treemacs-theme))
#+END_SRC

**** modus-themes

This is another themes collection with super configurable themes.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :defer t
  :custom
  (modus-themes-slanted-constructs t)
  (modus-themes-bold-constructs t)
  (modus-themes-mode-line 'borderless))
#+END_SRC

*** all-the-icons

You need to install the icons yourself[fn:4].
Packages =dired= and =ivy-rich= use and configure
their own sub-package.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer t)
#+END_SRC

*** doom-modeline

Busier and prettier =modeline=.
/Note/ that this package requires you to install =all-the-icons= fonts[fn:4].

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :defer 1
  :custom
  (doom-modeline-project-detection 'projectile)
  (doom-modeline-minor-modes t)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-icon t)
  (doom-modeline-vcs-max-length 20)
  :config
  (doom-modeline-mode 1))
#+END_SRC

*** mood-line

The light-weight variant.

#+begin_src emacs-lisp
(use-package mood-line
  :disabled
  :config
  (mood-line-mode))
#+end_src

*** beacon

Help me find my cursor!

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 2
  :config
  (beacon-mode 1)
  :custom
  (beacon-color 0.4)
  (beacon-blink-duration 0.4)
  (beacon-blink-delay 0.2)
  (beacon-size 60)
  (beacon-blink-when-point-moves-vertically 2)
  (beacon-blink-when-point-moves-horizontally 8))
#+END_SRC

*** dimmer

Dim inactive frames.
Make dimmed frames a bit dimmer.

#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :defer 2
  :diminish
  :custom
  (dimmer-fraction 0.3)
  (dimmer-adjustment-mode :foreground)
  :config
  (dimmer-configure-company-box)
  (dimmer-configure-hydra)
  (dimmer-configure-magit)
  (dimmer-configure-org)
  (dimmer-configure-which-key)
  (dimmer-mode t))
#+END_SRC

*** fira-code-mode

This mode allows us to use ligatures from FiraCode.
You don't need to use FiraCode as your main fixed font
for this to work.

#+BEGIN_SRC emacs-lisp
(defun wal/use-fira-code-mode ()
  "Determine whether `fira-code-mode' can/should be used.
Currently I've only encountered problems when using Monoid font
unless using the non-calt variant."
  (and (x-list-fonts "Fira Code Symbol")
       (not (string-match "Monoid" (face-font 'default)))))

(defun wal/fira-code ()
  "Wraps macro to only maybe enable."
  (use-package fira-code-mode
    :diminish
    ;; Use only if the code symbol font exists.
    :if (wal/use-fira-code-mode)
    :custom
    ;; Ligatures you don't want.
    (fira-code-mode-disabled-ligatures '("[]" "x"))
    :hook prog-mode))

;; We guard against font-related actions.
(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'wal/fira-code t)
  (add-hook 'after-init-hook 'wal/fira-code t))
#+END_SRC

*** diff-hl

Show diffs in the fringe.
Show diffs in =dired= buffers as well.
Refresh after =magit= is done.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 1
  :config
  (global-diff-hl-mode)
  :hook ((magit-post-refresh . diff-hl-magit-post-refresh)
         (dired-mode . diff-hl-dired-mode)))
#+END_SRC

*** delight

Refine a couple of =major-mode= names.

#+BEGIN_SRC emacs-lisp
(defvar wal/major-delight t
  "Whether some major modes are delighted beyond reason.")

(use-package delight
  :defer t
  :config
  (delight 'dired-mode "Dired" :major)
  (delight 'emacs-lisp-mode "Elisp" :major)
  (delight 'compilation-shell-minor-mode " csh" "compile")
  (delight 'c++-mode "CPP" :major)
  (delight 'abbrev-mode " abb" "abbrev")
  ;; Only confuse/delight if allowed.
  (when wal/major-delight
    (delight 'elixir-mode "Homebrew" :major)
    (delight 'c++-mode "*&" :major)
    (delight 'python-mode "Snake" :major)
    (delight 'js2-mode "NaNsense" :major)
    (delight 'inferior-python-mode "Bite" :major)))
#+END_SRC

*** highlight-indent-guides

Show indentation.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  ;; Don't need to see this.
  :diminish highlight-indent-guides-mode
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'top)
  :hook
  ((prog-mode . highlight-indent-guides-mode)
   (yaml-mode . highlight-indent-guides-mode)
   (whitespace-mode . (lambda() (highlight-indent-guides-mode -1))))
  :general
  (wal/colonel :keymaps '(prog-mode-map yaml-mode-map)
    "i" '(highlight-indent-guides-mode :wk "highlight indent")))
#+END_SRC

*** highlight-numbers

Make numbers stand out.

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

*** rainbow

Show colors in source code and make delimiters stand out.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

(use-package rainbow-mode
  :diminish
  :hook prog-mode)
#+END_SRC

*** hl-todo

Highlight =TODO=, =FIXME= etc. in =prog= modes.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook (prog-mode . hl-todo-mode))
#+END_SRC

*** whitespace-mode

Toggle =highlight-indent-guide= with =whitespace-mode=.

#+BEGIN_SRC emacs-lisp
(use-package whitespace-mode
  :ensure nil
  :general
  (wal/colonel "w" '(whitespace-mode :wk "whitespace")))
#+END_SRC

*** visual-fill-column

Makes presentations a bit nicer.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :defer t)
#+END_SRC

*** mode-line-bell

Make the bell visual.

#+BEGIN_SRC emacs-lisp
(use-package mode-line-bell
  :defer 2
  :custom
  (mode-line-bell-flash-time 0.1)
  :config
  (mode-line-bell-mode))
#+END_SRC

*** emojify

Display emojis.
You might have to call =emojify-download-emoji= to
download a set that supports your emojis.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :hook (dashboard-mode . emojify-mode)
  :general
  (wal/colonel "e" '(emojify-mode :wk "emojify")))
#+END_SRC

** DevOps

Put it into a container and throw it in the
garbage that is the Internet.

*** Docker

What goes =docker-compose= up, goes =docker-compose= down.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :defer 1 ; This package does not get autoloaded correctly.
  :config
  (wal/configure-focus-buffer-display "\\*docker-containers\\*")
  (wal/configure-shell-buffer-display "^\\* docker shell")
  :custom
  (docker-container-default-sort-key '("Names"))
  :bind
  (("C-c d" . docker)))
#+END_SRC

**** dockerfile-mode

Make =Dockerfiles= look nice.

#+BEGIN_SRC emacs-lisp
(defun wal/dockerfile-mode ()
  "Hook into `dockerfile-mode'."
  (message "Have you ever given?"))

(use-package dockerfile-mode
  :hook (dockerfile-mode . wal/dockerfile-mode))
#+END_SRC

** The Internet

I browse, I request.

*** eww

Browse web in Emacs.
This requires Emacs to have been compiled with =--with-xml2= flag.

#+BEGIN_SRC emacs-lisp
(defvar wal/eww-leader-key "H-b"
  "Leader key for `eww'.")

(general-create-definer wal/eww-leader
  :prefix wal/eww-leader-key
  :prefix-command 'wal/eww-command
  :prefix-map 'wal/eww-map
  :prefix-name "eww")

(use-package eww
  :ensure nil
  :general
  (wal/eww-leader
    "b" '(eww :wk "browse")
    "m" '(eww-list-bookmarks :wk "bookmarks")))
#+END_SRC

*** restclient

Postman is passé.
I use a =.http= file extension for my request examples.

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :config
  ;; Make it pop up a frame.
  (wal/configure-result-buffer-display "\\*HTTP Response\\*" t)
  :mode ("\\.http\\'" . restclient-mode)
  :bind
  (:map restclient-mode-map
   ("H-c" . evilnc-comment-or-uncomment-lines)))

;; We use this for hooks.
(use-package jq-mode
  :after restclient)
#+END_SRC

** Writing

Sometimes you have to sit down and write something.

*** typo

Access complex punctuation.
To me this doesn't necessarily make sense for all =text-mode=
modes (like =org-mode=), so instead it needs to be triggered
explicitly.

#+BEGIN_SRC emacs-lisp
(use-package typo
  :delight " typ"
  :general
  (wal/colonel :keymaps '(text-mode-map org-mode-map)
    "t" '(typo-mode :wk "toggle typo mode")))
#+END_SRC

*** writeroom-mode

Create a room of one's own.
I use a different (light) theme here.

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :hook ((writeroom-mode-enable . (lambda() (wal/light-switch 'secondary)))
         (writeroom-mode-disable . (lambda() (wal/light-switch 'primary))))
  :general
  (wal/colonel "r" '(writeroom-mode :wk "toggle writeroom")))
#+END_SRC

* Footnotes

[fn:1] Should also work in =27.1= that I used before.

[fn:2] If you're feeling adventurous, [[https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL][build from source]].

[fn:3] If you're not sure where your =user-emacs-directory= might be,
you can do the following:

+ Run Emacs
+ hit =M-x= (that is your Alt/Option key followed by the letter =x=)
+ type =describe-variable= and hit return
+ type =user-emacs-directory= and hit return again.

A window should pop up telling you the path.

Finally run =git clone git@gitlab.com:Walheimat/emacs-config.git ~/.emacs.d=
(replace =~/.emacs.d= with your actual path if it differs).

[fn:4] This config uses the =all-the-icons= package
whose icons need to be downloaded manually
by running =M-x all-the-icons-install-fonts= and selecting =yes=.

If the installation process should fail for any reason,
close Emacs and re-run it.

[fn:5] Around 140 code blocks.

[fn:6] Send me an email, why don't you?

[fn:7] To get a full overview you'll have to call =describe-personal-keybindings=
and =general-describe-keybindings=.

[fn:8] Be careful! If you make a mistake you could render your
keyboard unusable.

Alternatively you can run =xmodmap -pke > .Xmodmap= in your =HOME= directory
and edit your bindings there.

[fn:9] This requires =org-roam= to be loaded which only happens
after dispatch was invoked an the global minor mode is running.

[fn:10] Mostly from MELPA.
/Note/ that many packages bind keys.
Check the [[*Key Bindings][key bindings section]] if you need a list of the important ones.

[fn:11] All languages listed [[https://emacs-lsp.github.io/lsp-mode/page/languages/][here]].
